import { Component, ContentChildren, Directive, ElementRef, EventEmitter, HostBinding, HostListener, Inject, Input, Optional, Output, SkipSelf, TemplateRef, ViewChild } from '@angular/core';
import { takeUntil } from 'rxjs/operators';
import { DisplayDensity } from '../../core/density';
import { CurrentResourceStrings } from '../../core/i18n/resources';
import { ToggleAnimationPlayer } from '../../expansion-panel/toggle-animation-component';
import { IgxAngularAnimationService } from '../../services/animation/angular-animation-service';
import { IgxTreeSelectionType, IGX_TREE_COMPONENT, IGX_TREE_NODE_COMPONENT } from '../common';
import { IgxCircularProgressBarComponent } from '../../progressbar/progressbar.component';
import { IgxCheckboxComponent } from '../../checkbox/checkbox.component';
import { IgxIconComponent } from '../../icon/icon.component';
import { NgTemplateOutlet, NgIf, NgClass, NgFor } from '@angular/common';
import * as i0 from "@angular/core";
import * as i1 from "../tree-navigation.service";
import * as i2 from "../tree-selection.service";
import * as i3 from "../tree.service";
// TODO: Implement aria functionality
/**
 * @hidden @internal
 * Used for links (`a` tags) in the body of an `igx-tree-node`. Handles aria and event dispatch.
 */
export class IgxTreeNodeLinkDirective {
    /**
     * The node's parent. Should be used only when the link is defined
     * in `<ng-template>` tag outside of its parent, as Angular DI will not properly provide a reference
     *
     * ```html
     * <igx-tree>
     *     <igx-tree-node #myNode *ngFor="let node of data" [data]="node">
     *         <ng-template *ngTemplateOutlet="nodeTemplate; context: { $implicit: data, parentNode: myNode }">
     *         </ng-template>
     *     </igx-tree-node>
     *     ...
     *     <!-- node template is defined under tree to access related services -->
     *     <ng-template #nodeTemplate let-data let-node="parentNode">
     *         <a [igxTreeNodeLink]="node">{{ data.label }}</a>
     *     </ng-template>
     * </igx-tree>
     * ```
     */
    set parentNode(val) {
        if (val) {
            this._parentNode = val;
            this._parentNode.addLinkChild(this);
        }
    }
    get parentNode() {
        return this._parentNode;
    }
    /** A pointer to the parent node */
    get target() {
        return this.node || this.parentNode;
    }
    constructor(node, navService, elementRef) {
        this.node = node;
        this.navService = navService;
        this.elementRef = elementRef;
        this.role = 'treeitem';
        this._parentNode = null;
    }
    /** @hidden @internal */
    get tabIndex() {
        return this.navService.focusedNode === this.target ? (this.target?.disabled ? -1 : 0) : -1;
    }
    /**
     * @hidden @internal
     * Clear the node's focused state
     */
    handleBlur() {
        this.target.isFocused = false;
    }
    /**
     * @hidden @internal
     * Set the node as focused
     */
    handleFocus() {
        if (this.target && !this.target.disabled) {
            if (this.navService.focusedNode !== this.target) {
                this.navService.focusedNode = this.target;
            }
            this.target.isFocused = true;
        }
    }
    ngOnDestroy() {
        this.target.removeLinkChild(this);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.8", ngImport: i0, type: IgxTreeNodeLinkDirective, deps: [{ token: IGX_TREE_NODE_COMPONENT, optional: true }, { token: i1.IgxTreeNavigationService }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.8", type: IgxTreeNodeLinkDirective, isStandalone: true, selector: "[igxTreeNodeLink]", inputs: { parentNode: ["igxTreeNodeLink", "parentNode"] }, host: { listeners: { "blur": "handleBlur()", "focus": "handleFocus()" }, properties: { "attr.role": "this.role", "attr.tabindex": "this.tabIndex" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.8", ngImport: i0, type: IgxTreeNodeLinkDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: `[igxTreeNodeLink]`,
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [IGX_TREE_NODE_COMPONENT]
                }] }, { type: i1.IgxTreeNavigationService }, { type: i0.ElementRef }]; }, propDecorators: { role: [{
                type: HostBinding,
                args: ['attr.role']
            }], parentNode: [{
                type: Input,
                args: ['igxTreeNodeLink']
            }], tabIndex: [{
                type: HostBinding,
                args: ['attr.tabindex']
            }], handleBlur: [{
                type: HostListener,
                args: ['blur']
            }], handleFocus: [{
                type: HostListener,
                args: ['focus']
            }] } });
/**
 *
 * The tree node component represents a child node of the tree component or another tree node.
 * Usage:
 *
 * ```html
 *  <igx-tree>
 *  ...
 *    <igx-tree-node [data]="data" [selected]="service.isNodeSelected(data.Key)" [expanded]="service.isNodeExpanded(data.Key)">
 *      {{ data.FirstName }} {{ data.LastName }}
 *    </igx-tree-node>
 *  ...
 *  </igx-tree>
 * ```
 */
export class IgxTreeNodeComponent extends ToggleAnimationPlayer {
    // TO DO: return different tab index depending on anchor child
    /** @hidden @internal */
    set tabIndex(val) {
        this._tabIndex = val;
    }
    /** @hidden @internal */
    get tabIndex() {
        if (this.disabled) {
            return -1;
        }
        if (this._tabIndex === null) {
            if (this.navService.focusedNode === null) {
                return this.hasLinkChildren ? -1 : 0;
            }
            return -1;
        }
        return this.hasLinkChildren ? -1 : this._tabIndex;
    }
    /** @hidden @internal */
    get animationSettings() {
        return this.tree.animationSettings;
    }
    /**
     * Gets/Sets the resource strings.
     *
     * @remarks
     * Uses EN resources by default.
     */
    set resourceStrings(value) {
        this._resourceStrings = Object.assign({}, this._resourceStrings, value);
    }
    /**
     * An accessor that returns the resource strings.
     */
    get resourceStrings() {
        if (!this._resourceStrings) {
            this._resourceStrings = CurrentResourceStrings.TreeResStrings;
        }
        return this._resourceStrings;
    }
    /**
     * Gets/Sets the active state of the node
     *
     * @param value: boolean
     */
    set active(value) {
        if (value) {
            this.navService.activeNode = this;
            this.tree.activeNodeBindingChange.emit(this);
        }
    }
    get active() {
        return this.navService.activeNode === this;
    }
    /** @hidden @internal */
    get focused() {
        return this.isFocused &&
            this.navService.focusedNode === this;
    }
    /**
     * Retrieves the full path to the node incuding itself
     *
     * ```typescript
     * const node: IgxTreeNode<any> = this.tree.findNodes(data[0])[0];
     * const path: IgxTreeNode<any>[] = node.path;
     * ```
     */
    get path() {
        return this.parentNode?.path ? [...this.parentNode.path, this] : [this];
    }
    // TODO: bind to disabled state when node is dragged
    /**
     * Gets/Sets the disabled state of the node
     *
     * @param value: boolean
     */
    get disabled() {
        return this._disabled;
    }
    set disabled(value) {
        if (value !== this._disabled) {
            this._disabled = value;
            this.tree.disabledChange.emit(this);
        }
    }
    get size() {
        switch (this.tree.displayDensity) {
            case DisplayDensity.compact:
                return 'var(--ig-size, var(--ig-size-small))';
            case DisplayDensity.cosy:
                return 'var(--ig-size, var(--ig-size-medium))';
            case DisplayDensity.comfortable:
            default:
                return 'var(--ig-size, var(--ig-size-large))';
        }
    }
    /** @hidden @internal */
    get role() {
        return this.hasLinkChildren ? 'none' : 'treeitem';
    }
    /**
     * Return the child nodes of the node (if any)
     *
     * @remark
     * Returns `null` if node does not have children
     *
     * @example
     * ```typescript
     * const node: IgxTreeNode<any> = this.tree.findNodes(data[0])[0];
     * const children: IgxTreeNode<any>[] = node.children;
     * ```
     */
    get children() {
        return this._children?.length ? this._children.toArray() : null;
    }
    get hasLinkChildren() {
        return this.linkChildren?.length > 0 || this.registeredChildren?.length > 0;
    }
    /** @hidden @internal */
    get isCompact() {
        return this.tree?.displayDensity === DisplayDensity.compact;
    }
    /** @hidden @internal */
    get isCosy() {
        return this.tree?.displayDensity === DisplayDensity.cosy;
    }
    constructor(tree, selectionService, treeService, navService, cdr, animationService, element, parentNode) {
        super(animationService);
        this.tree = tree;
        this.selectionService = selectionService;
        this.treeService = treeService;
        this.navService = navService;
        this.cdr = cdr;
        this.element = element;
        this.parentNode = parentNode;
        /**
         * To be used for load-on-demand scenarios in order to specify whether the node is loading data.
         *
         * @remarks
         * Loading nodes do not render children.
         */
        this.loading = false;
        /**
         * Emitted when the node's `selected` property changes.
         *
         * ```html
         * <igx-tree>
         *      <igx-tree-node *ngFor="let node of data" [data]="node" [(selected)]="node.selected">
         *      </igx-tree-node>
         * </igx-tree>
         * ```
         *
         * ```typescript
         * const node: IgxTreeNode<any> = this.tree.findNodes(data[0])[0];
         * node.selectedChange.pipe(takeUntil(this.destroy$)).subscribe((e: boolean) => console.log("Node selection changed to ", e))
         * ```
         */
        this.selectedChange = new EventEmitter();
        /**
         * Emitted when the node's `expanded` property changes.
         *
         * ```html
         * <igx-tree>
         *      <igx-tree-node *ngFor="let node of data" [data]="node" [(expanded)]="node.expanded">
         *      </igx-tree-node>
         * </igx-tree>
         * ```
         *
         * ```typescript
         * const node: IgxTreeNode<any> = this.tree.findNodes(data[0])[0];
         * node.expandedChange.pipe(takeUntil(this.destroy$)).subscribe((e: boolean) => console.log("Node expansion state changed to ", e))
         * ```
         */
        this.expandedChange = new EventEmitter();
        /** @hidden @internal */
        this.cssClass = 'igx-tree-node';
        /** @hidden @internal */
        this.registeredChildren = [];
        /** @hidden @internal */
        this._resourceStrings = CurrentResourceStrings.TreeResStrings;
        this._tabIndex = null;
        this._disabled = false;
    }
    /**
     * @hidden @internal
     */
    get showSelectors() {
        return this.tree.selection !== IgxTreeSelectionType.None;
    }
    /**
     * @hidden @internal
     */
    get indeterminate() {
        return this.selectionService.isNodeIndeterminate(this);
    }
    /** The depth of the node, relative to the root
     *
     * ```html
     * <igx-tree>
     *  ...
     *  <igx-tree-node #node>
     *      My level is {{ node.level }}
     *  </igx-tree-node>
     * </igx-tree>
     * ```
     *
     * ```typescript
     * const node: IgxTreeNode<any> = this.tree.findNodes(data[12])[0];
     * const level: number = node.level;
     * ```
     */
    get level() {
        return this.parentNode ? this.parentNode.level + 1 : 0;
    }
    /** Get/set whether the node is selected. Supporst two-way binding.
     *
     * ```html
     * <igx-tree>
     *  ...
     *  <igx-tree-node *ngFor="let node of data" [(selected)]="node.selected">
     *      {{ node.label }}
     *  </igx-tree-node>
     * </igx-tree>
     * ```
     *
     * ```typescript
     * const node: IgxTreeNode<any> = this.tree.findNodes(data[0])[0];
     * const selected = node.selected;
     * node.selected = true;
     * ```
     */
    get selected() {
        return this.selectionService.isNodeSelected(this);
    }
    set selected(val) {
        if (!(this.tree?.nodes && this.tree.nodes.find((e) => e === this)) && val) {
            this.tree.forceSelect.push(this);
            return;
        }
        if (val && !this.selectionService.isNodeSelected(this)) {
            this.selectionService.selectNodesWithNoEvent([this]);
        }
        if (!val && this.selectionService.isNodeSelected(this)) {
            this.selectionService.deselectNodesWithNoEvent([this]);
        }
    }
    /** Get/set whether the node is expanded
     *
     * ```html
     * <igx-tree>
     *  ...
     *  <igx-tree-node *ngFor="let node of data" [expanded]="node.name === this.expandedNode">
     *      {{ node.label }}
     *  </igx-tree-node>
     * </igx-tree>
     * ```
     *
     * ```typescript
     * const node: IgxTreeNode<any> = this.tree.findNodes(data[0])[0];
     * const expanded = node.expanded;
     * node.expanded = true;
     * ```
     */
    get expanded() {
        return this.treeService.isExpanded(this);
    }
    set expanded(val) {
        if (val) {
            this.treeService.expand(this, false);
        }
        else {
            this.treeService.collapse(this);
        }
    }
    /** @hidden @internal */
    get expandIndicatorTemplate() {
        return this.tree?.expandIndicator || this._defaultExpandIndicatorTemplate;
    }
    /**
     * The native DOM element representing the node. Could be null in certain environments.
     *
     * ```typescript
     * // get the nativeElement of the second node
     * const node: IgxTreeNode = this.tree.nodes.first();
     * const nodeElement: HTMLElement = node.nativeElement;
     * ```
     */
    /** @hidden @internal */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /** @hidden @internal */
    ngOnInit() {
        this.openAnimationDone.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.tree.nodeExpanded.emit({ owner: this.tree, node: this });
        });
        this.closeAnimationDone.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.tree.nodeCollapsed.emit({ owner: this.tree, node: this });
            this.treeService.collapse(this);
            this.cdr.markForCheck();
        });
    }
    /**
     * @hidden @internal
     * Sets the focus to the node's <a> child, if present
     * Sets the node as the tree service's focusedNode
     * Marks the node as the current active element
     */
    handleFocus() {
        if (this.disabled) {
            return;
        }
        if (this.navService.focusedNode !== this) {
            this.navService.focusedNode = this;
        }
        this.isFocused = true;
        if (this.linkChildren?.length) {
            this.linkChildren.first.nativeElement.focus();
            return;
        }
        if (this.registeredChildren.length) {
            this.registeredChildren[0].elementRef.nativeElement.focus();
            return;
        }
    }
    /**
     * @hidden @internal
     * Clear the node's focused status
     */
    clearFocus() {
        this.isFocused = false;
    }
    /**
     * @hidden @internal
     */
    onSelectorClick(event) {
        // event.stopPropagation();
        event.preventDefault();
        // this.navService.handleFocusedAndActiveNode(this);
        if (event.shiftKey) {
            this.selectionService.selectMultipleNodes(this, event);
            return;
        }
        if (this.selected) {
            this.selectionService.deselectNode(this, event);
        }
        else {
            this.selectionService.selectNode(this, event);
        }
    }
    /**
     * Toggles the node expansion state, triggering animation
     *
     * ```html
     * <igx-tree>
     *      <igx-tree-node #node>My Node</igx-tree-node>
     * </igx-tree>
     * <button type="button" igxButton (click)="node.toggle()">Toggle Node</button>
     * ```
     *
     * ```typescript
     * const myNode: IgxTreeNode<any> = this.tree.findNodes(data[0])[0];
     * myNode.toggle();
     * ```
     */
    toggle() {
        if (this.expanded) {
            this.collapse();
        }
        else {
            this.expand();
        }
    }
    /** @hidden @internal */
    indicatorClick() {
        this.toggle();
        this.navService.setFocusedAndActiveNode(this);
    }
    /**
     * @hidden @internal
     */
    onPointerDown(event) {
        event.stopPropagation();
        this.navService.setFocusedAndActiveNode(this);
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        this.selectionService.ensureStateOnNodeDelete(this);
    }
    /**
     * Expands the node, triggering animation
     *
     * ```html
     * <igx-tree>
     *      <igx-tree-node #node>My Node</igx-tree-node>
     * </igx-tree>
     * <button type="button" igxButton (click)="node.expand()">Expand Node</button>
     * ```
     *
     * ```typescript
     * const myNode: IgxTreeNode<any> = this.tree.findNodes(data[0])[0];
     * myNode.expand();
     * ```
     */
    expand() {
        if (this.expanded && !this.treeService.collapsingNodes.has(this)) {
            return;
        }
        const args = {
            owner: this.tree,
            node: this,
            cancel: false
        };
        this.tree.nodeExpanding.emit(args);
        if (!args.cancel) {
            this.treeService.expand(this, true);
            this.cdr.detectChanges();
            this.playOpenAnimation(this.childrenContainer);
        }
    }
    /**
     * Collapses the node, triggering animation
     *
     * ```html
     * <igx-tree>
     *      <igx-tree-node #node>My Node</igx-tree-node>
     * </igx-tree>
     * <button type="button" igxButton (click)="node.collapse()">Collapse Node</button>
     * ```
     *
     * ```typescript
     * const myNode: IgxTreeNode<any> = this.tree.findNodes(data[0])[0];
     * myNode.collapse();
     * ```
     */
    collapse() {
        if (!this.expanded || this.treeService.collapsingNodes.has(this)) {
            return;
        }
        const args = {
            owner: this.tree,
            node: this,
            cancel: false
        };
        this.tree.nodeCollapsing.emit(args);
        if (!args.cancel) {
            this.treeService.collapsing(this);
            this.playCloseAnimation(this.childrenContainer);
        }
    }
    /** @hidden @internal */
    addLinkChild(link) {
        this._tabIndex = -1;
        this.registeredChildren.push(link);
    }
    /** @hidden @internal */
    removeLinkChild(link) {
        const index = this.registeredChildren.indexOf(link);
        if (index !== -1) {
            this.registeredChildren.splice(index, 1);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.8", ngImport: i0, type: IgxTreeNodeComponent, deps: [{ token: IGX_TREE_COMPONENT }, { token: i2.IgxTreeSelectionService }, { token: i3.IgxTreeService }, { token: i1.IgxTreeNavigationService }, { token: i0.ChangeDetectorRef }, { token: IgxAngularAnimationService }, { token: i0.ElementRef }, { token: IGX_TREE_NODE_COMPONENT, optional: true, skipSelf: true }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.8", type: IgxTreeNodeComponent, isStandalone: true, selector: "igx-tree-node", inputs: { data: "data", loading: "loading", resourceStrings: "resourceStrings", active: "active", disabled: "disabled", selected: "selected", expanded: "expanded" }, outputs: { selectedChange: "selectedChange", expandedChange: "expandedChange" }, host: { properties: { "class.igx-tree-node--disabled": "this.disabled", "class.igx-tree-node": "this.cssClass", "style.--component-size": "this.size", "attr.role": "this.role" } }, providers: [
            { provide: IGX_TREE_NODE_COMPONENT, useExisting: IgxTreeNodeComponent }
        ], queries: [{ propertyName: "linkChildren", predicate: IgxTreeNodeLinkDirective, read: ElementRef }, { propertyName: "_children", predicate: IGX_TREE_NODE_COMPONENT, read: IGX_TREE_NODE_COMPONENT }, { propertyName: "allChildren", predicate: IGX_TREE_NODE_COMPONENT, descendants: true, read: IGX_TREE_NODE_COMPONENT }], viewQueries: [{ propertyName: "header", first: true, predicate: ["ghostTemplate"], descendants: true, read: ElementRef }, { propertyName: "_defaultExpandIndicatorTemplate", first: true, predicate: ["defaultIndicator"], descendants: true, read: TemplateRef, static: true }, { propertyName: "childrenContainer", first: true, predicate: ["childrenContainer"], descendants: true, read: ElementRef }], usesInheritance: true, ngImport: i0, template: "<ng-template #noDragTemplate>\n    <ng-template *ngTemplateOutlet=\"headerTemplate\"></ng-template>\n</ng-template>\n\n<!-- Will switch templates depending on dragDrop -->\n<ng-template *ngTemplateOutlet=\"noDragTemplate\">\n</ng-template>\n\n<div #childrenContainer\n    *ngIf=\"expanded && !loading\"\n    class=\"igx-tree-node__group\"\n    role=\"group\"\n>\n    <ng-content select=\"igx-tree-node\"></ng-content>\n</div>\n\n\n<ng-template #defaultIndicator>\n    <igx-icon [attr.aria-label]=\"expanded ? resourceStrings.igx_collapse : resourceStrings.igx_expand\">\n        {{ expanded ? \"keyboard_arrow_down\" : \"keyboard_arrow_right\" }}\n    </igx-icon>\n</ng-template>\n\n<!-- separated in a template in case this ever needs to be templatable -->\n<ng-template #selectMarkerTemplate>\n    <igx-checkbox [checked]=\"selected\" [readonly]=\"true\" [indeterminate]=\"indeterminate\" [tabindex]=\"-1\">\n    </igx-checkbox>\n</ng-template>\n\n<ng-template #headerTemplate>\n    <div #ghostTemplate class=\"igx-tree-node__wrapper\"\n        [attr.role]=\"role\"\n        [tabIndex]=\"tabIndex\"\n        [ngClass]=\"{\n            'igx-tree-node__wrapper--selected': selected,\n            'igx-tree-node__wrapper--active' : this.active,\n            'igx-tree-node__wrapper--focused' : this.focused,\n            'igx-tree-node__wrapper--disabled' : this.disabled\n        }\"\n        (pointerdown)=\"onPointerDown($event)\"\n        (focus)=\"handleFocus()\"\n        (blur)=\"clearFocus()\"\n    >\n        <div aria-hidden=\"true\">\n            <span *ngFor=\"let item of [].constructor(level)\"\n                aria-hidden=\"true\"\n                class=\"igx-tree-node__spacer\"\n            ></span>\n        </div>\n\n        <!-- Expand/Collapse indicator -->\n        <span *ngIf=\"!loading\"\n            class=\"igx-tree-node__toggle-button\"\n            [ngClass]=\"{ 'igx-tree-node__toggle-button--hidden': !_children?.length }\"\n            (click)=\"indicatorClick()\"\n        >\n            <ng-container *ngTemplateOutlet=\"expandIndicatorTemplate, context: { $implicit: expanded }\">\n            </ng-container>\n        </span>\n        <span *ngIf=\"loading\"\n            class=\"igx-tree-node__toggle-button\"\n        >\n        \t<igx-circular-bar\n            \t[animate]=\"false\"\n            \t[indeterminate]=\"true\"\n            \t[textVisibility]=\"false\"\n        \t>\n        \t</igx-circular-bar>\n        </span>\n\n        <!-- Item selection -->\n        <div *ngIf=\"showSelectors\"\n            class=\"igx-tree-node__select\"\n            (pointerdown)=\"$event.preventDefault()\"\n            (click)=\"onSelectorClick($event)\">\n            <ng-container *ngTemplateOutlet=\"selectMarkerTemplate\">\n            </ng-container>\n        </div>\n\n        <div class=\"igx-tree-node__content\">\n            <!-- Ghost content -->\n            <ng-content></ng-content>\n        </div>\n    </div>\n\n    <!--  Buffer element for 'move after' when D&D is implemented-->\n    <div class=\"igx-tree-node__drop-indicator\">\n        <span aria-hidden=\"true\" class=\"igx-tree-node__spacer\" *ngFor=\"let item of [].constructor(level)\"></span>\n        <!-- style rules target this div, do not delete it -->\n        <div></div>\n    </div>\n</ng-template>\n\n<ng-template #dragTemplate>\n    <!-- Drag drop goes here\n        igxDrop\n        #dropRef=\"drop\"\n        [igxNodeDrag]=\"this\"\n        (dragStart)=\"logDrop(dropRef)\"\n        (leave)=\"emitLeave()\"\n        (enter)=\"emitEnter()\" -->\n    <div class=\"igx-tree-node__drag-wrapper\">\n        <ng-template *ngTemplateOutlet=\"headerTemplate\"></ng-template>\n    </div>\n</ng-template>\n", dependencies: [{ kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: IgxIconComponent, selector: "igx-icon", inputs: ["family", "active", "name"] }, { kind: "component", type: IgxCheckboxComponent, selector: "igx-checkbox", inputs: ["id", "labelId", "value", "name", "tabindex", "labelPosition", "disableRipple", "required", "aria-labelledby", "aria-label", "indeterminate", "checked", "disabled", "invalid", "readonly", "disableTransitions"], outputs: ["change"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "component", type: IgxCircularProgressBarComponent, selector: "igx-circular-bar", inputs: ["id", "isIndeterminate", "textVisibility", "text"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.8", ngImport: i0, type: IgxTreeNodeComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igx-tree-node', providers: [
                        { provide: IGX_TREE_NODE_COMPONENT, useExisting: IgxTreeNodeComponent }
                    ], standalone: true, imports: [NgTemplateOutlet, NgIf, IgxIconComponent, IgxCheckboxComponent, NgClass, NgFor, IgxCircularProgressBarComponent], template: "<ng-template #noDragTemplate>\n    <ng-template *ngTemplateOutlet=\"headerTemplate\"></ng-template>\n</ng-template>\n\n<!-- Will switch templates depending on dragDrop -->\n<ng-template *ngTemplateOutlet=\"noDragTemplate\">\n</ng-template>\n\n<div #childrenContainer\n    *ngIf=\"expanded && !loading\"\n    class=\"igx-tree-node__group\"\n    role=\"group\"\n>\n    <ng-content select=\"igx-tree-node\"></ng-content>\n</div>\n\n\n<ng-template #defaultIndicator>\n    <igx-icon [attr.aria-label]=\"expanded ? resourceStrings.igx_collapse : resourceStrings.igx_expand\">\n        {{ expanded ? \"keyboard_arrow_down\" : \"keyboard_arrow_right\" }}\n    </igx-icon>\n</ng-template>\n\n<!-- separated in a template in case this ever needs to be templatable -->\n<ng-template #selectMarkerTemplate>\n    <igx-checkbox [checked]=\"selected\" [readonly]=\"true\" [indeterminate]=\"indeterminate\" [tabindex]=\"-1\">\n    </igx-checkbox>\n</ng-template>\n\n<ng-template #headerTemplate>\n    <div #ghostTemplate class=\"igx-tree-node__wrapper\"\n        [attr.role]=\"role\"\n        [tabIndex]=\"tabIndex\"\n        [ngClass]=\"{\n            'igx-tree-node__wrapper--selected': selected,\n            'igx-tree-node__wrapper--active' : this.active,\n            'igx-tree-node__wrapper--focused' : this.focused,\n            'igx-tree-node__wrapper--disabled' : this.disabled\n        }\"\n        (pointerdown)=\"onPointerDown($event)\"\n        (focus)=\"handleFocus()\"\n        (blur)=\"clearFocus()\"\n    >\n        <div aria-hidden=\"true\">\n            <span *ngFor=\"let item of [].constructor(level)\"\n                aria-hidden=\"true\"\n                class=\"igx-tree-node__spacer\"\n            ></span>\n        </div>\n\n        <!-- Expand/Collapse indicator -->\n        <span *ngIf=\"!loading\"\n            class=\"igx-tree-node__toggle-button\"\n            [ngClass]=\"{ 'igx-tree-node__toggle-button--hidden': !_children?.length }\"\n            (click)=\"indicatorClick()\"\n        >\n            <ng-container *ngTemplateOutlet=\"expandIndicatorTemplate, context: { $implicit: expanded }\">\n            </ng-container>\n        </span>\n        <span *ngIf=\"loading\"\n            class=\"igx-tree-node__toggle-button\"\n        >\n        \t<igx-circular-bar\n            \t[animate]=\"false\"\n            \t[indeterminate]=\"true\"\n            \t[textVisibility]=\"false\"\n        \t>\n        \t</igx-circular-bar>\n        </span>\n\n        <!-- Item selection -->\n        <div *ngIf=\"showSelectors\"\n            class=\"igx-tree-node__select\"\n            (pointerdown)=\"$event.preventDefault()\"\n            (click)=\"onSelectorClick($event)\">\n            <ng-container *ngTemplateOutlet=\"selectMarkerTemplate\">\n            </ng-container>\n        </div>\n\n        <div class=\"igx-tree-node__content\">\n            <!-- Ghost content -->\n            <ng-content></ng-content>\n        </div>\n    </div>\n\n    <!--  Buffer element for 'move after' when D&D is implemented-->\n    <div class=\"igx-tree-node__drop-indicator\">\n        <span aria-hidden=\"true\" class=\"igx-tree-node__spacer\" *ngFor=\"let item of [].constructor(level)\"></span>\n        <!-- style rules target this div, do not delete it -->\n        <div></div>\n    </div>\n</ng-template>\n\n<ng-template #dragTemplate>\n    <!-- Drag drop goes here\n        igxDrop\n        #dropRef=\"drop\"\n        [igxNodeDrag]=\"this\"\n        (dragStart)=\"logDrop(dropRef)\"\n        (leave)=\"emitLeave()\"\n        (enter)=\"emitEnter()\" -->\n    <div class=\"igx-tree-node__drag-wrapper\">\n        <ng-template *ngTemplateOutlet=\"headerTemplate\"></ng-template>\n    </div>\n</ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [IGX_TREE_COMPONENT]
                }] }, { type: i2.IgxTreeSelectionService }, { type: i3.IgxTreeService }, { type: i1.IgxTreeNavigationService }, { type: i0.ChangeDetectorRef }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [IgxAngularAnimationService]
                }] }, { type: i0.ElementRef }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: SkipSelf
                }, {
                    type: Inject,
                    args: [IGX_TREE_NODE_COMPONENT]
                }] }]; }, propDecorators: { data: [{
                type: Input
            }], loading: [{
                type: Input
            }], resourceStrings: [{
                type: Input
            }], active: [{
                type: Input
            }], selectedChange: [{
                type: Output
            }], expandedChange: [{
                type: Output
            }], disabled: [{
                type: Input
            }, {
                type: HostBinding,
                args: ['class.igx-tree-node--disabled']
            }], cssClass: [{
                type: HostBinding,
                args: ['class.igx-tree-node']
            }], size: [{
                type: HostBinding,
                args: ['style.--component-size']
            }], role: [{
                type: HostBinding,
                args: ['attr.role']
            }], linkChildren: [{
                type: ContentChildren,
                args: [IgxTreeNodeLinkDirective, { read: ElementRef }]
            }], _children: [{
                type: ContentChildren,
                args: [IGX_TREE_NODE_COMPONENT, { read: IGX_TREE_NODE_COMPONENT }]
            }], allChildren: [{
                type: ContentChildren,
                args: [IGX_TREE_NODE_COMPONENT, { read: IGX_TREE_NODE_COMPONENT, descendants: true }]
            }], header: [{
                type: ViewChild,
                args: ['ghostTemplate', { read: ElementRef }]
            }], _defaultExpandIndicatorTemplate: [{
                type: ViewChild,
                args: ['defaultIndicator', { read: TemplateRef, static: true }]
            }], childrenContainer: [{
                type: ViewChild,
                args: ['childrenContainer', { read: ElementRef }]
            }], selected: [{
                type: Input
            }], expanded: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS1ub2RlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi90cmVlL3RyZWUtbm9kZS90cmVlLW5vZGUuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL3RyZWUvdHJlZS1ub2RlL3RyZWUtbm9kZS5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBRUgsU0FBUyxFQUNULGVBQWUsRUFDZixTQUFTLEVBQ1QsVUFBVSxFQUNWLFlBQVksRUFDWixXQUFXLEVBQ1gsWUFBWSxFQUNaLE1BQU0sRUFDTixLQUFLLEVBR0wsUUFBUSxFQUNSLE1BQU0sRUFFTixRQUFRLEVBQ1IsV0FBVyxFQUNYLFNBQVMsRUFDWixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDM0MsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQ3BELE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBRW5FLE9BQU8sRUFBRSxxQkFBcUIsRUFBMkIsTUFBTSxrREFBa0QsQ0FBQztBQUNsSCxPQUFPLEVBQUUsMEJBQTBCLEVBQUUsTUFBTSxvREFBb0QsQ0FBQztBQUVoRyxPQUFPLEVBR0gsb0JBQW9CLEVBQ3BCLGtCQUFrQixFQUNsQix1QkFBdUIsRUFFMUIsTUFBTSxXQUFXLENBQUM7QUFJbkIsT0FBTyxFQUFFLCtCQUErQixFQUFFLE1BQU0seUNBQXlDLENBQUM7QUFDMUYsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sbUNBQW1DLENBQUM7QUFDekUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDN0QsT0FBTyxFQUFFLGdCQUFn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RUFBRSxFQUFFLElBQUksRUFBRSx1QkFBdUIsRUFBRSxXQUFXLEVBQUUsSUFBSSxFQUFFO2dCQXNCdkYsTUFBTTtzQkFEWixTQUFTO3VCQUFDLGVBQWUsRUFBRSxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUU7Z0JBSXhDLCtCQUErQjtzQkFEdEMsU0FBUzt1QkFBQyxrQkFBa0IsRUFBRSxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTtnQkFJMUQsaUJBQWlCO3NCQUR4QixTQUFTO3VCQUFDLG1CQUFtQixFQUFFLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRTtnQkE4RnpDLFFBQVE7c0JBRGxCLEtBQUs7Z0JBb0NLLFFBQVE7c0JBRGxCLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgIENvbXBvbmVudCxcbiAgICBDb250ZW50Q2hpbGRyZW4sXG4gICAgRGlyZWN0aXZlLFxuICAgIEVsZW1lbnRSZWYsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIEhvc3RCaW5kaW5nLFxuICAgIEhvc3RMaXN0ZW5lcixcbiAgICBJbmplY3QsXG4gICAgSW5wdXQsXG4gICAgT25EZXN0cm95LFxuICAgIE9uSW5pdCxcbiAgICBPcHRpb25hbCxcbiAgICBPdXRwdXQsXG4gICAgUXVlcnlMaXN0LFxuICAgIFNraXBTZWxmLFxuICAgIFRlbXBsYXRlUmVmLFxuICAgIFZpZXdDaGlsZFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IERpc3BsYXlEZW5zaXR5IH0gZnJvbSAnLi4vLi4vY29yZS9kZW5zaXR5JztcbmltcG9ydCB7IEN1cnJlbnRSZXNvdXJjZVN0cmluZ3MgfSBmcm9tICcuLi8uLi9jb3JlL2kxOG4vcmVzb3VyY2VzJztcbmltcG9ydCB7IElUcmVlUmVzb3VyY2VTdHJpbmdzIH0gZnJvbSAnLi4vLi4vY29yZS9pMThuL3RyZWUtcmVzb3VyY2VzJztcbmltcG9ydCB7IFRvZ2dsZUFuaW1hdGlvblBsYXllciwgVG9nZ2xlQW5pbWF0aW9uU2V0dGluZ3MgfSBmcm9tICcuLi8uLi9leHBhbnNpb24tcGFuZWwvdG9nZ2xlLWFuaW1hdGlvbi1jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4QW5ndWxhckFuaW1hdGlvblNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9hbmltYXRpb24vYW5ndWxhci1hbmltYXRpb24tc2VydmljZSc7XG5pbXBvcnQgeyBBbmltYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvYW5pbWF0aW9uL2FuaW1hdGlvbic7XG5pbXBvcnQge1xuICAgIElneFRyZWUsXG4gICAgSWd4VHJlZU5vZGUsXG4gICAgSWd4VHJlZVNlbGVjdGlvblR5cGUsXG4gICAgSUdYX1RSRUVfQ09NUE9ORU5ULFxuICAgIElHWF9UUkVFX05PREVfQ09NUE9ORU5ULFxuICAgIElUcmVlTm9kZVRvZ2dsaW5nRXZlbnRBcmdzXG59IGZyb20gJy4uL2NvbW1vbic7XG5pbXBvcnQgeyBJZ3hUcmVlTmF2aWdhdGlvblNlcnZpY2UgfSBmcm9tICcuLi90cmVlLW5hdmlnYXRpb24uc2VydmljZSc7XG5pbXBvcnQgeyBJZ3hUcmVlU2VsZWN0aW9uU2VydmljZSB9IGZyb20gJy4uL3RyZWUtc2VsZWN0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgSWd4VHJlZVNlcnZpY2UgfSBmcm9tICcuLi90cmVlLnNlcnZpY2UnO1xuaW1wb3J0IHsgSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudCB9IGZyb20gJy4uLy4uL3Byb2dyZXNzYmFyL3Byb2dyZXNzYmFyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hDaGVja2JveENvbXBvbmVudCB9IGZyb20gJy4uLy4uL2NoZWNrYm94L2NoZWNrYm94LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hJY29uQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vaWNvbi9pY29uLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBOZ1RlbXBsYXRlT3V0bGV0LCBOZ0lmLCBOZ0NsYXNzLCBOZ0ZvciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cbi8vIFRPRE86IEltcGxlbWVudCBhcmlhIGZ1bmN0aW9uYWxpdHlcbi8qKlxuICogQGhpZGRlbiBAaW50ZXJuYWxcbiAqIFVzZWQgZm9yIGxpbmtzIChgYWAgdGFncykgaW4gdGhlIGJvZHkgb2YgYW4gYGlneC10cmVlLW5vZGVgLiBIYW5kbGVzIGFyaWEgYW5kIGV2ZW50IGRpc3BhdGNoLlxuICovXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogYFtpZ3hUcmVlTm9kZUxpbmtdYCxcbiAgICBzdGFuZGFsb25lOiB0cnVlXG59KVxuZXhwb3J0IGNsYXNzIElneFRyZWVOb2RlTGlua0RpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIucm9sZScpXG4gICAgcHVibGljIHJvbGUgPSAndHJlZWl0ZW0nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5vZGUncyBwYXJlbnQuIFNob3VsZCBiZSB1c2VkIG9ubHkgd2hlbiB0aGUgbGluayBpcyBkZWZpbmVkXG4gICAgICogaW4gYDxuZy10ZW1wbGF0ZT5gIHRhZyBvdXRzaWRlIG9mIGl0cyBwYXJlbnQsIGFzIEFuZ3VsYXIgREkgd2lsbCBub3QgcHJvcGVybHkgcHJvdmlkZSBhIHJlZmVyZW5jZVxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdHJlZT5cbiAgICAgKiAgICAgPGlneC10cmVlLW5vZGUgI215Tm9kZSAqbmdGb3I9XCJsZXQgbm9kZSBvZiBkYXRhXCIgW2RhdGFdPVwibm9kZVwiPlxuICAgICAqICAgICAgICAgPG5nLXRlbXBsYXRlICpuZ1RlbXBsYXRlT3V0bGV0PVwibm9kZVRlbXBsYXRlOyBjb250ZXh0OiB7ICRpbXBsaWNpdDogZGF0YSwgcGFyZW50Tm9kZTogbXlOb2RlIH1cIj5cbiAgICAgKiAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICogICAgIDwvaWd4LXRyZWUtbm9kZT5cbiAgICAgKiAgICAgLi4uXG4gICAgICogICAgIDwhLS0gbm9kZSB0ZW1wbGF0ZSBpcyBkZWZpbmVkIHVuZGVyIHRyZWUgdG8gYWNjZXNzIHJlbGF0ZWQgc2VydmljZXMgLS0+XG4gICAgICogICAgIDxuZy10ZW1wbGF0ZSAjbm9kZVRlbXBsYXRlIGxldC1kYXRhIGxldC1ub2RlPVwicGFyZW50Tm9kZVwiPlxuICAgICAqICAgICAgICAgPGEgW2lneFRyZWVOb2RlTGlua109XCJub2RlXCI+e3sgZGF0YS5sYWJlbCB9fTwvYT5cbiAgICAgKiAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgKiA8L2lneC10cmVlPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgnaWd4VHJlZU5vZGVMaW5rJylcbiAgICBwdWJsaWMgc2V0IHBhcmVudE5vZGUodmFsOiBhbnkpIHtcbiAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50Tm9kZSA9IHZhbDtcbiAgICAgICAgICAgICh0aGlzLl9wYXJlbnROb2RlIGFzIGFueSkuYWRkTGlua0NoaWxkKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBwYXJlbnROb2RlKCk6IGFueSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIC8qKiBBIHBvaW50ZXIgdG8gdGhlIHBhcmVudCBub2RlICovXG4gICAgcHJpdmF0ZSBnZXQgdGFyZ2V0KCk6IElneFRyZWVOb2RlPGFueT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlIHx8IHRoaXMucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9wYXJlbnROb2RlOiBJZ3hUcmVlTm9kZTxhbnk+ID0gbnVsbDtcblxuICAgIGNvbnN0cnVjdG9yKEBPcHRpb25hbCgpIEBJbmplY3QoSUdYX1RSRUVfTk9ERV9DT01QT05FTlQpXG4gICAgcHJpdmF0ZSBub2RlOiBJZ3hUcmVlTm9kZTxhbnk+LFxuICAgICAgICBwcml2YXRlIG5hdlNlcnZpY2U6IElneFRyZWVOYXZpZ2F0aW9uU2VydmljZSxcbiAgICAgICAgcHVibGljIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIudGFiaW5kZXgnKVxuICAgIHB1YmxpYyBnZXQgdGFiSW5kZXgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmF2U2VydmljZS5mb2N1c2VkTm9kZSA9PT0gdGhpcy50YXJnZXQgPyAodGhpcy50YXJnZXQ/LmRpc2FibGVkID8gLTEgOiAwKSA6IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogQ2xlYXIgdGhlIG5vZGUncyBmb2N1c2VkIHN0YXRlXG4gICAgICovXG4gICAgQEhvc3RMaXN0ZW5lcignYmx1cicpXG4gICAgcHVibGljIGhhbmRsZUJsdXIoKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0LmlzRm9jdXNlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogU2V0IHRoZSBub2RlIGFzIGZvY3VzZWRcbiAgICAgKi9cbiAgICBASG9zdExpc3RlbmVyKCdmb2N1cycpXG4gICAgcHVibGljIGhhbmRsZUZvY3VzKCkge1xuICAgICAgICBpZiAodGhpcy50YXJnZXQgJiYgIXRoaXMudGFyZ2V0LmRpc2FibGVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uYXZTZXJ2aWNlLmZvY3VzZWROb2RlICE9PSB0aGlzLnRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRoaXMubmF2U2VydmljZS5mb2N1c2VkTm9kZSA9IHRoaXMudGFyZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50YXJnZXQuaXNGb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlTGlua0NoaWxkKHRoaXMpO1xuICAgIH1cbn1cblxuLyoqXG4gKlxuICogVGhlIHRyZWUgbm9kZSBjb21wb25lbnQgcmVwcmVzZW50cyBhIGNoaWxkIG5vZGUgb2YgdGhlIHRyZWUgY29tcG9uZW50IG9yIGFub3RoZXIgdHJlZSBub2RlLlxuICogVXNhZ2U6XG4gKlxuICogYGBgaHRtbFxuICogIDxpZ3gtdHJlZT5cbiAqICAuLi5cbiAqICAgIDxpZ3gtdHJlZS1ub2RlIFtkYXRhXT1cImRhdGFcIiBbc2VsZWN0ZWRdPVwic2VydmljZS5pc05vZGVTZWxlY3RlZChkYXRhLktleSlcIiBbZXhwYW5kZWRdPVwic2VydmljZS5pc05vZGVFeHBhbmRlZChkYXRhLktleSlcIj5cbiAqICAgICAge3sgZGF0YS5GaXJzdE5hbWUgfX0ge3sgZGF0YS5MYXN0TmFtZSB9fVxuICogICAgPC9pZ3gtdHJlZS1ub2RlPlxuICogIC4uLlxuICogIDwvaWd4LXRyZWU+XG4gKiBgYGBcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdpZ3gtdHJlZS1ub2RlJyxcbiAgICB0ZW1wbGF0ZVVybDogJ3RyZWUtbm9kZS5jb21wb25lbnQuaHRtbCcsXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIHsgcHJvdmlkZTogSUdYX1RSRUVfTk9ERV9DT01QT05FTlQsIHVzZUV4aXN0aW5nOiBJZ3hUcmVlTm9kZUNvbXBvbmVudCB9XG4gICAgXSxcbiAgICBzdGFuZGFsb25lOiB0cnVlLFxuICAgIGltcG9ydHM6IFtOZ1RlbXBsYXRlT3V0bGV0LCBOZ0lmLCBJZ3hJY29uQ29tcG9uZW50LCBJZ3hDaGVja2JveENvbXBvbmVudCwgTmdDbGFzcywgTmdGb3IsIElneENpcmN1bGFyUHJvZ3Jlc3NCYXJDb21wb25lbnRdXG59KVxuZXhwb3J0IGNsYXNzIElneFRyZWVOb2RlQ29tcG9uZW50PFQ+IGV4dGVuZHMgVG9nZ2xlQW5pbWF0aW9uUGxheWVyIGltcGxlbWVudHMgSWd4VHJlZU5vZGU8VD4sIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgICAvKipcbiAgICAgKiBUaGUgZGF0YSBlbnRyeSB0aGF0IHRoZSBub2RlIGlzIHZpc3VhbGl6aW5nLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBSZXF1aXJlZCBmb3Igc2VhcmNoaW5nIHRocm91Z2ggbm9kZXMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiAgPGlneC10cmVlPlxuICAgICAqICAuLi5cbiAgICAgKiAgICA8aWd4LXRyZWUtbm9kZSBbZGF0YV09XCJkYXRhXCI+XG4gICAgICogICAgICB7eyBkYXRhLkZpcnN0TmFtZSB9fSB7eyBkYXRhLkxhc3ROYW1lIH19XG4gICAgICogICAgPC9pZ3gtdHJlZS1ub2RlPlxuICAgICAqICAuLi5cbiAgICAgKiAgPC9pZ3gtdHJlZT5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBkYXRhOiBUO1xuXG4gICAgLyoqXG4gICAgICogVG8gYmUgdXNlZCBmb3IgbG9hZC1vbi1kZW1hbmQgc2NlbmFyaW9zIGluIG9yZGVyIHRvIHNwZWNpZnkgd2hldGhlciB0aGUgbm9kZSBpcyBsb2FkaW5nIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIExvYWRpbmcgbm9kZXMgZG8gbm90IHJlbmRlciBjaGlsZHJlbi5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBsb2FkaW5nID0gZmFsc2U7XG5cbiAgICAvLyBUTyBETzogcmV0dXJuIGRpZmZlcmVudCB0YWIgaW5kZXggZGVwZW5kaW5nIG9uIGFuY2hvciBjaGlsZFxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBzZXQgdGFiSW5kZXgodmFsOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fdGFiSW5kZXggPSB2YWw7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIGdldCB0YWJJbmRleCgpOiBudW1iZXIge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl90YWJJbmRleCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubmF2U2VydmljZS5mb2N1c2VkTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc0xpbmtDaGlsZHJlbiA/IC0xIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5oYXNMaW5rQ2hpbGRyZW4gPyAtMSA6IHRoaXMuX3RhYkluZGV4O1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBvdmVycmlkZSBnZXQgYW5pbWF0aW9uU2V0dGluZ3MoKTogVG9nZ2xlQW5pbWF0aW9uU2V0dGluZ3Mge1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlLmFuaW1hdGlvblNldHRpbmdzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB0aGUgcmVzb3VyY2Ugc3RyaW5ncy5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVXNlcyBFTiByZXNvdXJjZXMgYnkgZGVmYXVsdC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgcmVzb3VyY2VTdHJpbmdzKHZhbHVlOiBJVHJlZVJlc291cmNlU3RyaW5ncykge1xuICAgICAgICB0aGlzLl9yZXNvdXJjZVN0cmluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9yZXNvdXJjZVN0cmluZ3MsIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBhY2Nlc3NvciB0aGF0IHJldHVybnMgdGhlIHJlc291cmNlIHN0cmluZ3MuXG4gICAgICovXG4gICAgcHVibGljIGdldCByZXNvdXJjZVN0cmluZ3MoKTogSVRyZWVSZXNvdXJjZVN0cmluZ3Mge1xuICAgICAgICBpZiAoIXRoaXMuX3Jlc291cmNlU3RyaW5ncykge1xuICAgICAgICAgICAgdGhpcy5fcmVzb3VyY2VTdHJpbmdzID0gQ3VycmVudFJlc291cmNlU3RyaW5ncy5UcmVlUmVzU3RyaW5ncztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcmVzb3VyY2VTdHJpbmdzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB0aGUgYWN0aXZlIHN0YXRlIG9mIHRoZSBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWU6IGJvb2xlYW5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgYWN0aXZlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5uYXZTZXJ2aWNlLmFjdGl2ZU5vZGUgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy50cmVlLmFjdGl2ZU5vZGVCaW5kaW5nQ2hhbmdlLmVtaXQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGFjdGl2ZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmF2U2VydmljZS5hY3RpdmVOb2RlID09PSB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiB0aGUgbm9kZSdzIGBzZWxlY3RlZGAgcHJvcGVydHkgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRyZWU+XG4gICAgICogICAgICA8aWd4LXRyZWUtbm9kZSAqbmdGb3I9XCJsZXQgbm9kZSBvZiBkYXRhXCIgW2RhdGFdPVwibm9kZVwiIFsoc2VsZWN0ZWQpXT1cIm5vZGUuc2VsZWN0ZWRcIj5cbiAgICAgKiAgICAgIDwvaWd4LXRyZWUtbm9kZT5cbiAgICAgKiA8L2lneC10cmVlPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IG5vZGU6IElneFRyZWVOb2RlPGFueT4gPSB0aGlzLnRyZWUuZmluZE5vZGVzKGRhdGFbMF0pWzBdO1xuICAgICAqIG5vZGUuc2VsZWN0ZWRDaGFuZ2UucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpLnN1YnNjcmliZSgoZTogYm9vbGVhbikgPT4gY29uc29sZS5sb2coXCJOb2RlIHNlbGVjdGlvbiBjaGFuZ2VkIHRvIFwiLCBlKSlcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgc2VsZWN0ZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4gdGhlIG5vZGUncyBgZXhwYW5kZWRgIHByb3BlcnR5IGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC10cmVlPlxuICAgICAqICAgICAgPGlneC10cmVlLW5vZGUgKm5nRm9yPVwibGV0IG5vZGUgb2YgZGF0YVwiIFtkYXRhXT1cIm5vZGVcIiBbKGV4cGFuZGVkKV09XCJub2RlLmV4cGFuZGVkXCI+XG4gICAgICogICAgICA8L2lneC10cmVlLW5vZGU+XG4gICAgICogPC9pZ3gtdHJlZT5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBub2RlOiBJZ3hUcmVlTm9kZTxhbnk+ID0gdGhpcy50cmVlLmZpbmROb2RlcyhkYXRhWzBdKVswXTtcbiAgICAgKiBub2RlLmV4cGFuZGVkQ2hhbmdlLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKS5zdWJzY3JpYmUoKGU6IGJvb2xlYW4pID0+IGNvbnNvbGUubG9nKFwiTm9kZSBleHBhbnNpb24gc3RhdGUgY2hhbmdlZCB0byBcIiwgZSkpXG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGV4cGFuZGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIGdldCBmb2N1c2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0ZvY3VzZWQgJiZcbiAgICAgICAgICAgIHRoaXMubmF2U2VydmljZS5mb2N1c2VkTm9kZSA9PT0gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGZ1bGwgcGF0aCB0byB0aGUgbm9kZSBpbmN1ZGluZyBpdHNlbGZcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBub2RlOiBJZ3hUcmVlTm9kZTxhbnk+ID0gdGhpcy50cmVlLmZpbmROb2RlcyhkYXRhWzBdKVswXTtcbiAgICAgKiBjb25zdCBwYXRoOiBJZ3hUcmVlTm9kZTxhbnk+W10gPSBub2RlLnBhdGg7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCBwYXRoKCk6IElneFRyZWVOb2RlPGFueT5bXSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudE5vZGU/LnBhdGggPyBbLi4udGhpcy5wYXJlbnROb2RlLnBhdGgsIHRoaXNdIDogW3RoaXNdO1xuICAgIH1cblxuICAgIC8vIFRPRE86IGJpbmQgdG8gZGlzYWJsZWQgc3RhdGUgd2hlbiBub2RlIGlzIGRyYWdnZWRcbiAgICAvKipcbiAgICAgKiBHZXRzL1NldHMgdGhlIGRpc2FibGVkIHN0YXRlIG9mIHRoZSBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWU6IGJvb2xlYW5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LXRyZWUtbm9kZS0tZGlzYWJsZWQnKVxuICAgIHB1YmxpYyBnZXQgZGlzYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZDtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IGRpc2FibGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVkID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnRyZWUuZGlzYWJsZWRDaGFuZ2UuZW1pdCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LXRyZWUtbm9kZScpXG4gICAgcHVibGljIGNzc0NsYXNzID0gJ2lneC10cmVlLW5vZGUnO1xuXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS4tLWNvbXBvbmVudC1zaXplJylcbiAgICBwdWJsaWMgZ2V0IHNpemUoKTogc3RyaW5nIHtcbiAgICAgICAgc3dpdGNoKHRoaXMudHJlZS5kaXNwbGF5RGVuc2l0eSkge1xuICAgICAgICAgICAgY2FzZSBEaXNwbGF5RGVuc2l0eS5jb21wYWN0OlxuICAgICAgICAgICAgICAgIHJldHVybiAndmFyKC0taWctc2l6ZSwgdmFyKC0taWctc2l6ZS1zbWFsbCkpJztcbiAgICAgICAgICAgIGNhc2UgRGlzcGxheURlbnNpdHkuY29zeTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3ZhcigtLWlnLXNpemUsIHZhcigtLWlnLXNpemUtbWVkaXVtKSknO1xuICAgICAgICAgICAgY2FzZSBEaXNwbGF5RGVuc2l0eS5jb21mb3J0YWJsZTpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICd2YXIoLS1pZy1zaXplLCB2YXIoLS1pZy1zaXplLWxhcmdlKSknO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLnJvbGUnKVxuICAgIHB1YmxpYyBnZXQgcm9sZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzTGlua0NoaWxkcmVuID8gJ25vbmUnIDogJ3RyZWVpdGVtJztcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBAQ29udGVudENoaWxkcmVuKElneFRyZWVOb2RlTGlua0RpcmVjdGl2ZSwgeyByZWFkOiBFbGVtZW50UmVmIH0pXG4gICAgcHVibGljIGxpbmtDaGlsZHJlbjogUXVlcnlMaXN0PEVsZW1lbnRSZWY+O1xuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgQENvbnRlbnRDaGlsZHJlbihJR1hfVFJFRV9OT0RFX0NPTVBPTkVOVCwgeyByZWFkOiBJR1hfVFJFRV9OT0RFX0NPTVBPTkVOVCB9KVxuICAgIHB1YmxpYyBfY2hpbGRyZW46IFF1ZXJ5TGlzdDxJZ3hUcmVlTm9kZTxhbnk+PjtcblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIEBDb250ZW50Q2hpbGRyZW4oSUdYX1RSRUVfTk9ERV9DT01QT05FTlQsIHsgcmVhZDogSUdYX1RSRUVfTk9ERV9DT01QT05FTlQsIGRlc2NlbmRhbnRzOiB0cnVlIH0pXG4gICAgcHVibGljIGFsbENoaWxkcmVuOiBRdWVyeUxpc3Q8SWd4VHJlZU5vZGU8YW55Pj47XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGNoaWxkIG5vZGVzIG9mIHRoZSBub2RlIChpZiBhbnkpXG4gICAgICpcbiAgICAgKiBAcmVtYXJrXG4gICAgICogUmV0dXJucyBgbnVsbGAgaWYgbm9kZSBkb2VzIG5vdCBoYXZlIGNoaWxkcmVuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBub2RlOiBJZ3hUcmVlTm9kZTxhbnk+ID0gdGhpcy50cmVlLmZpbmROb2RlcyhkYXRhWzBdKVswXTtcbiAgICAgKiBjb25zdCBjaGlsZHJlbjogSWd4VHJlZU5vZGU8YW55PltdID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGNoaWxkcmVuKCk6IElneFRyZWVOb2RlPGFueT5bXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbj8ubGVuZ3RoID8gdGhpcy5fY2hpbGRyZW4udG9BcnJheSgpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiB3aWxsIGJlIHVzZWQgaW4gRHJhZyBhbmQgRHJvcCBpbXBsZW1lbnRhdGlvblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIEBWaWV3Q2hpbGQoJ2dob3N0VGVtcGxhdGUnLCB7IHJlYWQ6IEVsZW1lbnRSZWYgfSlcbiAgICBwdWJsaWMgaGVhZGVyOiBFbGVtZW50UmVmO1xuXG4gICAgQFZpZXdDaGlsZCgnZGVmYXVsdEluZGljYXRvcicsIHsgcmVhZDogVGVtcGxhdGVSZWYsIHN0YXRpYzogdHJ1ZSB9KVxuICAgIHByaXZhdGUgX2RlZmF1bHRFeHBhbmRJbmRpY2F0b3JUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIEBWaWV3Q2hpbGQoJ2NoaWxkcmVuQ29udGFpbmVyJywgeyByZWFkOiBFbGVtZW50UmVmIH0pXG4gICAgcHJpdmF0ZSBjaGlsZHJlbkNvbnRhaW5lcjogRWxlbWVudFJlZjtcblxuICAgIHByaXZhdGUgZ2V0IGhhc0xpbmtDaGlsZHJlbigpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlua0NoaWxkcmVuPy5sZW5ndGggPiAwIHx8IHRoaXMucmVnaXN0ZXJlZENoaWxkcmVuPy5sZW5ndGggPiAwO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBnZXQgaXNDb21wYWN0KCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlPy5kaXNwbGF5RGVuc2l0eSA9PT0gRGlzcGxheURlbnNpdHkuY29tcGFjdDtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgZ2V0IGlzQ29zeSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZT8uZGlzcGxheURlbnNpdHkgPT09IERpc3BsYXlEZW5zaXR5LmNvc3k7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIGlzRm9jdXNlZDogYm9vbGVhbjtcblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyByZWdpc3RlcmVkQ2hpbGRyZW46IElneFRyZWVOb2RlTGlua0RpcmVjdGl2ZVtdID0gW107XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwcml2YXRlIF9yZXNvdXJjZVN0cmluZ3MgPSBDdXJyZW50UmVzb3VyY2VTdHJpbmdzLlRyZWVSZXNTdHJpbmdzO1xuXG4gICAgcHJpdmF0ZSBfdGFiSW5kZXggPSBudWxsO1xuICAgIHByaXZhdGUgX2Rpc2FibGVkID0gZmFsc2U7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgQEluamVjdChJR1hfVFJFRV9DT01QT05FTlQpIHB1YmxpYyB0cmVlOiBJZ3hUcmVlLFxuICAgICAgICBwcm90ZWN0ZWQgc2VsZWN0aW9uU2VydmljZTogSWd4VHJlZVNlbGVjdGlvblNlcnZpY2UsXG4gICAgICAgIHByb3RlY3RlZCB0cmVlU2VydmljZTogSWd4VHJlZVNlcnZpY2UsXG4gICAgICAgIHByb3RlY3RlZCBuYXZTZXJ2aWNlOiBJZ3hUcmVlTmF2aWdhdGlvblNlcnZpY2UsXG4gICAgICAgIHByb3RlY3RlZCBjZHI6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBASW5qZWN0KElneEFuZ3VsYXJBbmltYXRpb25TZXJ2aWNlKSBhbmltYXRpb25TZXJ2aWNlOiBBbmltYXRpb25TZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIGVsZW1lbnQ6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+LFxuICAgICAgICBAT3B0aW9uYWwoKSBAU2tpcFNlbGYoKSBASW5qZWN0KElHWF9UUkVFX05PREVfQ09NUE9ORU5UKSBwdWJsaWMgcGFyZW50Tm9kZTogSWd4VHJlZU5vZGU8YW55PlxuICAgICkge1xuICAgICAgICBzdXBlcihhbmltYXRpb25TZXJ2aWNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgc2hvd1NlbGVjdG9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZS5zZWxlY3Rpb24gIT09IElneFRyZWVTZWxlY3Rpb25UeXBlLk5vbmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGluZGV0ZXJtaW5hdGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvblNlcnZpY2UuaXNOb2RlSW5kZXRlcm1pbmF0ZSh0aGlzKTtcbiAgICB9XG5cbiAgICAvKiogVGhlIGRlcHRoIG9mIHRoZSBub2RlLCByZWxhdGl2ZSB0byB0aGUgcm9vdFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdHJlZT5cbiAgICAgKiAgLi4uXG4gICAgICogIDxpZ3gtdHJlZS1ub2RlICNub2RlPlxuICAgICAqICAgICAgTXkgbGV2ZWwgaXMge3sgbm9kZS5sZXZlbCB9fVxuICAgICAqICA8L2lneC10cmVlLW5vZGU+XG4gICAgICogPC9pZ3gtdHJlZT5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBub2RlOiBJZ3hUcmVlTm9kZTxhbnk+ID0gdGhpcy50cmVlLmZpbmROb2RlcyhkYXRhWzEyXSlbMF07XG4gICAgICogY29uc3QgbGV2ZWw6IG51bWJlciA9IG5vZGUubGV2ZWw7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCBsZXZlbCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnROb2RlID8gdGhpcy5wYXJlbnROb2RlLmxldmVsICsgMSA6IDA7XG4gICAgfVxuXG4gICAgLyoqIEdldC9zZXQgd2hldGhlciB0aGUgbm9kZSBpcyBzZWxlY3RlZC4gU3VwcG9yc3QgdHdvLXdheSBiaW5kaW5nLlxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdHJlZT5cbiAgICAgKiAgLi4uXG4gICAgICogIDxpZ3gtdHJlZS1ub2RlICpuZ0Zvcj1cImxldCBub2RlIG9mIGRhdGFcIiBbKHNlbGVjdGVkKV09XCJub2RlLnNlbGVjdGVkXCI+XG4gICAgICogICAgICB7eyBub2RlLmxhYmVsIH19XG4gICAgICogIDwvaWd4LXRyZWUtbm9kZT5cbiAgICAgKiA8L2lneC10cmVlPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IG5vZGU6IElneFRyZWVOb2RlPGFueT4gPSB0aGlzLnRyZWUuZmluZE5vZGVzKGRhdGFbMF0pWzBdO1xuICAgICAqIGNvbnN0IHNlbGVjdGVkID0gbm9kZS5zZWxlY3RlZDtcbiAgICAgKiBub2RlLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgc2VsZWN0ZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvblNlcnZpY2UuaXNOb2RlU2VsZWN0ZWQodGhpcyk7XG4gICAgfVxuXG4gICAgcHVibGljIHNldCBzZWxlY3RlZCh2YWw6IGJvb2xlYW4pIHtcbiAgICAgICAgaWYgKCEodGhpcy50cmVlPy5ub2RlcyAmJiB0aGlzLnRyZWUubm9kZXMuZmluZCgoZSkgPT4gZSA9PT0gdGhpcykpICYmIHZhbCkge1xuICAgICAgICAgICAgdGhpcy50cmVlLmZvcmNlU2VsZWN0LnB1c2godGhpcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbCAmJiAhdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmlzTm9kZVNlbGVjdGVkKHRoaXMpKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2Uuc2VsZWN0Tm9kZXNXaXRoTm9FdmVudChbdGhpc10pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdmFsICYmIHRoaXMuc2VsZWN0aW9uU2VydmljZS5pc05vZGVTZWxlY3RlZCh0aGlzKSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmRlc2VsZWN0Tm9kZXNXaXRoTm9FdmVudChbdGhpc10pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEdldC9zZXQgd2hldGhlciB0aGUgbm9kZSBpcyBleHBhbmRlZFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdHJlZT5cbiAgICAgKiAgLi4uXG4gICAgICogIDxpZ3gtdHJlZS1ub2RlICpuZ0Zvcj1cImxldCBub2RlIG9mIGRhdGFcIiBbZXhwYW5kZWRdPVwibm9kZS5uYW1lID09PSB0aGlzLmV4cGFuZGVkTm9kZVwiPlxuICAgICAqICAgICAge3sgbm9kZS5sYWJlbCB9fVxuICAgICAqICA8L2lneC10cmVlLW5vZGU+XG4gICAgICogPC9pZ3gtdHJlZT5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBub2RlOiBJZ3hUcmVlTm9kZTxhbnk+ID0gdGhpcy50cmVlLmZpbmROb2RlcyhkYXRhWzBdKVswXTtcbiAgICAgKiBjb25zdCBleHBhbmRlZCA9IG5vZGUuZXhwYW5kZWQ7XG4gICAgICogbm9kZS5leHBhbmRlZCA9IHRydWU7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IGV4cGFuZGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlU2VydmljZS5pc0V4cGFuZGVkKHRoaXMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgZXhwYW5kZWQodmFsOiBib29sZWFuKSB7XG4gICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMudHJlZVNlcnZpY2UuZXhwYW5kKHRoaXMsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHJlZVNlcnZpY2UuY29sbGFwc2UodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgZ2V0IGV4cGFuZEluZGljYXRvclRlbXBsYXRlKCk6IFRlbXBsYXRlUmVmPGFueT4ge1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlPy5leHBhbmRJbmRpY2F0b3IgfHwgdGhpcy5fZGVmYXVsdEV4cGFuZEluZGljYXRvclRlbXBsYXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBuYXRpdmUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBub2RlLiBDb3VsZCBiZSBudWxsIGluIGNlcnRhaW4gZW52aXJvbm1lbnRzLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGdldCB0aGUgbmF0aXZlRWxlbWVudCBvZiB0aGUgc2Vjb25kIG5vZGVcbiAgICAgKiBjb25zdCBub2RlOiBJZ3hUcmVlTm9kZSA9IHRoaXMudHJlZS5ub2Rlcy5maXJzdCgpO1xuICAgICAqIGNvbnN0IG5vZGVFbGVtZW50OiBIVE1MRWxlbWVudCA9IG5vZGUubmF0aXZlRWxlbWVudDtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgZ2V0IG5hdGl2ZUVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMub3BlbkFuaW1hdGlvbkRvbmUucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpLnN1YnNjcmliZShcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyZWUubm9kZUV4cGFuZGVkLmVtaXQoeyBvd25lcjogdGhpcy50cmVlLCBub2RlOiB0aGlzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICB0aGlzLmNsb3NlQW5pbWF0aW9uRG9uZS5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJlZS5ub2RlQ29sbGFwc2VkLmVtaXQoeyBvd25lcjogdGhpcy50cmVlLCBub2RlOiB0aGlzIH0pO1xuICAgICAgICAgICAgdGhpcy50cmVlU2VydmljZS5jb2xsYXBzZSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIFNldHMgdGhlIGZvY3VzIHRvIHRoZSBub2RlJ3MgPGE+IGNoaWxkLCBpZiBwcmVzZW50XG4gICAgICogU2V0cyB0aGUgbm9kZSBhcyB0aGUgdHJlZSBzZXJ2aWNlJ3MgZm9jdXNlZE5vZGVcbiAgICAgKiBNYXJrcyB0aGUgbm9kZSBhcyB0aGUgY3VycmVudCBhY3RpdmUgZWxlbWVudFxuICAgICAqL1xuICAgIHB1YmxpYyBoYW5kbGVGb2N1cygpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uYXZTZXJ2aWNlLmZvY3VzZWROb2RlICE9PSB0aGlzKSB7XG4gICAgICAgICAgICB0aGlzLm5hdlNlcnZpY2UuZm9jdXNlZE5vZGUgPSB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNGb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMubGlua0NoaWxkcmVuPy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMubGlua0NoaWxkcmVuLmZpcnN0Lm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWdpc3RlcmVkQ2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRDaGlsZHJlblswXS5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogQ2xlYXIgdGhlIG5vZGUncyBmb2N1c2VkIHN0YXR1c1xuICAgICAqL1xuICAgIHB1YmxpYyBjbGVhckZvY3VzKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmlzRm9jdXNlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIG9uU2VsZWN0b3JDbGljayhldmVudCkge1xuICAgICAgICAvLyBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgLy8gdGhpcy5uYXZTZXJ2aWNlLmhhbmRsZUZvY3VzZWRBbmRBY3RpdmVOb2RlKHRoaXMpO1xuICAgICAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5zZWxlY3RNdWx0aXBsZU5vZGVzKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmRlc2VsZWN0Tm9kZSh0aGlzLCBldmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2Uuc2VsZWN0Tm9kZSh0aGlzLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSBub2RlIGV4cGFuc2lvbiBzdGF0ZSwgdHJpZ2dlcmluZyBhbmltYXRpb25cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRyZWU+XG4gICAgICogICAgICA8aWd4LXRyZWUtbm9kZSAjbm9kZT5NeSBOb2RlPC9pZ3gtdHJlZS1ub2RlPlxuICAgICAqIDwvaWd4LXRyZWU+XG4gICAgICogPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgaWd4QnV0dG9uIChjbGljayk9XCJub2RlLnRvZ2dsZSgpXCI+VG9nZ2xlIE5vZGU8L2J1dHRvbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBteU5vZGU6IElneFRyZWVOb2RlPGFueT4gPSB0aGlzLnRyZWUuZmluZE5vZGVzKGRhdGFbMF0pWzBdO1xuICAgICAqIG15Tm9kZS50b2dnbGUoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgdG9nZ2xlKCkge1xuICAgICAgICBpZiAodGhpcy5leHBhbmRlZCkge1xuICAgICAgICAgICAgdGhpcy5jb2xsYXBzZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5leHBhbmQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBpbmRpY2F0b3JDbGljaygpIHtcbiAgICAgICAgdGhpcy50b2dnbGUoKTtcbiAgICAgICAgdGhpcy5uYXZTZXJ2aWNlLnNldEZvY3VzZWRBbmRBY3RpdmVOb2RlKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIG9uUG9pbnRlckRvd24oZXZlbnQpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHRoaXMubmF2U2VydmljZS5zZXRGb2N1c2VkQW5kQWN0aXZlTm9kZSh0aGlzKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLm5nT25EZXN0cm95KCk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5lbnN1cmVTdGF0ZU9uTm9kZURlbGV0ZSh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHBhbmRzIHRoZSBub2RlLCB0cmlnZ2VyaW5nIGFuaW1hdGlvblxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdHJlZT5cbiAgICAgKiAgICAgIDxpZ3gtdHJlZS1ub2RlICNub2RlPk15IE5vZGU8L2lneC10cmVlLW5vZGU+XG4gICAgICogPC9pZ3gtdHJlZT5cbiAgICAgKiA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBpZ3hCdXR0b24gKGNsaWNrKT1cIm5vZGUuZXhwYW5kKClcIj5FeHBhbmQgTm9kZTwvYnV0dG9uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IG15Tm9kZTogSWd4VHJlZU5vZGU8YW55PiA9IHRoaXMudHJlZS5maW5kTm9kZXMoZGF0YVswXSlbMF07XG4gICAgICogbXlOb2RlLmV4cGFuZCgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBleHBhbmQoKSB7XG4gICAgICAgIGlmICh0aGlzLmV4cGFuZGVkICYmICF0aGlzLnRyZWVTZXJ2aWNlLmNvbGxhcHNpbmdOb2Rlcy5oYXModGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcmdzOiBJVHJlZU5vZGVUb2dnbGluZ0V2ZW50QXJncyA9IHtcbiAgICAgICAgICAgIG93bmVyOiB0aGlzLnRyZWUsXG4gICAgICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICAgICAgY2FuY2VsOiBmYWxzZVxuXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudHJlZS5ub2RlRXhwYW5kaW5nLmVtaXQoYXJncyk7XG4gICAgICAgIGlmICghYXJncy5jYW5jZWwpIHtcbiAgICAgICAgICAgIHRoaXMudHJlZVNlcnZpY2UuZXhwYW5kKHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgdGhpcy5wbGF5T3BlbkFuaW1hdGlvbihcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuQ29udGFpbmVyXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29sbGFwc2VzIHRoZSBub2RlLCB0cmlnZ2VyaW5nIGFuaW1hdGlvblxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdHJlZT5cbiAgICAgKiAgICAgIDxpZ3gtdHJlZS1ub2RlICNub2RlPk15IE5vZGU8L2lneC10cmVlLW5vZGU+XG4gICAgICogPC9pZ3gtdHJlZT5cbiAgICAgKiA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBpZ3hCdXR0b24gKGNsaWNrKT1cIm5vZGUuY29sbGFwc2UoKVwiPkNvbGxhcHNlIE5vZGU8L2J1dHRvbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBteU5vZGU6IElneFRyZWVOb2RlPGFueT4gPSB0aGlzLnRyZWUuZmluZE5vZGVzKGRhdGFbMF0pWzBdO1xuICAgICAqIG15Tm9kZS5jb2xsYXBzZSgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBjb2xsYXBzZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmV4cGFuZGVkIHx8IHRoaXMudHJlZVNlcnZpY2UuY29sbGFwc2luZ05vZGVzLmhhcyh0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFyZ3M6IElUcmVlTm9kZVRvZ2dsaW5nRXZlbnRBcmdzID0ge1xuICAgICAgICAgICAgb3duZXI6IHRoaXMudHJlZSxcbiAgICAgICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgICAgICBjYW5jZWw6IGZhbHNlXG5cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50cmVlLm5vZGVDb2xsYXBzaW5nLmVtaXQoYXJncyk7XG4gICAgICAgIGlmICghYXJncy5jYW5jZWwpIHtcbiAgICAgICAgICAgIHRoaXMudHJlZVNlcnZpY2UuY29sbGFwc2luZyh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucGxheUNsb3NlQW5pbWF0aW9uKFxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5Db250YWluZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgYWRkTGlua0NoaWxkKGxpbms6IElneFRyZWVOb2RlTGlua0RpcmVjdGl2ZSkge1xuICAgICAgICB0aGlzLl90YWJJbmRleCA9IC0xO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRDaGlsZHJlbi5wdXNoKGxpbmspO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyByZW1vdmVMaW5rQ2hpbGQobGluazogSWd4VHJlZU5vZGVMaW5rRGlyZWN0aXZlKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5yZWdpc3RlcmVkQ2hpbGRyZW4uaW5kZXhPZihsaW5rKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlcmVkQ2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIjxuZy10ZW1wbGF0ZSAjbm9EcmFnVGVtcGxhdGU+XG4gICAgPG5nLXRlbXBsYXRlICpuZ1RlbXBsYXRlT3V0bGV0PVwiaGVhZGVyVGVtcGxhdGVcIj48L25nLXRlbXBsYXRlPlxuPC9uZy10ZW1wbGF0ZT5cblxuPCEtLSBXaWxsIHN3aXRjaCB0ZW1wbGF0ZXMgZGVwZW5kaW5nIG9uIGRyYWdEcm9wIC0tPlxuPG5nLXRlbXBsYXRlICpuZ1RlbXBsYXRlT3V0bGV0PVwibm9EcmFnVGVtcGxhdGVcIj5cbjwvbmctdGVtcGxhdGU+XG5cbjxkaXYgI2NoaWxkcmVuQ29udGFpbmVyXG4gICAgKm5nSWY9XCJleHBhbmRlZCAmJiAhbG9hZGluZ1wiXG4gICAgY2xhc3M9XCJpZ3gtdHJlZS1ub2RlX19ncm91cFwiXG4gICAgcm9sZT1cImdyb3VwXCJcbj5cbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJpZ3gtdHJlZS1ub2RlXCI+PC9uZy1jb250ZW50PlxuPC9kaXY+XG5cblxuPG5nLXRlbXBsYXRlICNkZWZhdWx0SW5kaWNhdG9yPlxuICAgIDxpZ3gtaWNvbiBbYXR0ci5hcmlhLWxhYmVsXT1cImV4cGFuZGVkID8gcmVzb3VyY2VTdHJpbmdzLmlneF9jb2xsYXBzZSA6IHJlc291cmNlU3RyaW5ncy5pZ3hfZXhwYW5kXCI+XG4gICAgICAgIHt7IGV4cGFuZGVkID8gXCJrZXlib2FyZF9hcnJvd19kb3duXCIgOiBcImtleWJvYXJkX2Fycm93X3JpZ2h0XCIgfX1cbiAgICA8L2lneC1pY29uPlxuPC9uZy10ZW1wbGF0ZT5cblxuPCEtLSBzZXBhcmF0ZWQgaW4gYSB0ZW1wbGF0ZSBpbiBjYXNlIHRoaXMgZXZlciBuZWVkcyB0byBiZSB0ZW1wbGF0YWJsZSAtLT5cbjxuZy10ZW1wbGF0ZSAjc2VsZWN0TWFya2VyVGVtcGxhdGU+XG4gICAgPGlneC1jaGVja2JveCBbY2hlY2tlZF09XCJzZWxlY3RlZFwiIFtyZWFkb25seV09XCJ0cnVlXCIgW2luZGV0ZXJtaW5hdGVdPVwiaW5kZXRlcm1pbmF0ZVwiIFt0YWJpbmRleF09XCItMVwiPlxuICAgIDwvaWd4LWNoZWNrYm94PlxuPC9uZy10ZW1wbGF0ZT5cblxuPG5nLXRlbXBsYXRlICNoZWFkZXJUZW1wbGF0ZT5cbiAgICA8ZGl2ICNnaG9zdFRlbXBsYXRlIGNsYXNzPVwiaWd4LXRyZWUtbm9kZV9fd3JhcHBlclwiXG4gICAgICAgIFthdHRyLnJvbGVdPVwicm9sZVwiXG4gICAgICAgIFt0YWJJbmRleF09XCJ0YWJJbmRleFwiXG4gICAgICAgIFtuZ0NsYXNzXT1cIntcbiAgICAgICAgICAgICdpZ3gtdHJlZS1ub2RlX193cmFwcGVyLS1zZWxlY3RlZCc6IHNlbGVjdGVkLFxuICAgICAgICAgICAgJ2lneC10cmVlLW5vZGVfX3dyYXBwZXItLWFjdGl2ZScgOiB0aGlzLmFjdGl2ZSxcbiAgICAgICAgICAgICdpZ3gtdHJlZS1ub2RlX193cmFwcGVyLS1mb2N1c2VkJyA6IHRoaXMuZm9jdXNlZCxcbiAgICAgICAgICAgICdpZ3gtdHJlZS1ub2RlX193cmFwcGVyLS1kaXNhYmxlZCcgOiB0aGlzLmRpc2FibGVkXG4gICAgICAgIH1cIlxuICAgICAgICAocG9pbnRlcmRvd24pPVwib25Qb2ludGVyRG93bigkZXZlbnQpXCJcbiAgICAgICAgKGZvY3VzKT1cImhhbmRsZUZvY3VzKClcIlxuICAgICAgICAoYmx1cik9XCJjbGVhckZvY3VzKClcIlxuICAgID5cbiAgICAgICAgPGRpdiBhcmlhLWhpZGRlbj1cInRydWVcIj5cbiAgICAgICAgICAgIDxzcGFuICpuZ0Zvcj1cImxldCBpdGVtIG9mIFtdLmNvbnN0cnVjdG9yKGxldmVsKVwiXG4gICAgICAgICAgICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cImlneC10cmVlLW5vZGVfX3NwYWNlclwiXG4gICAgICAgICAgICA+PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8IS0tIEV4cGFuZC9Db2xsYXBzZSBpbmRpY2F0b3IgLS0+XG4gICAgICAgIDxzcGFuICpuZ0lmPVwiIWxvYWRpbmdcIlxuICAgICAgICAgICAgY2xhc3M9XCJpZ3gtdHJlZS1ub2RlX190b2dnbGUtYnV0dG9uXCJcbiAgICAgICAgICAgIFtuZ0NsYXNzXT1cInsgJ2lneC10cmVlLW5vZGVfX3RvZ2dsZS1idXR0b24tLWhpZGRlbic6ICFfY2hpbGRyZW4/Lmxlbmd0aCB9XCJcbiAgICAgICAgICAgIChjbGljayk9XCJpbmRpY2F0b3JDbGljaygpXCJcbiAgICAgICAgPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImV4cGFuZEluZGljYXRvclRlbXBsYXRlLCBjb250ZXh0OiB7ICRpbXBsaWNpdDogZXhwYW5kZWQgfVwiPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPHNwYW4gKm5nSWY9XCJsb2FkaW5nXCJcbiAgICAgICAgICAgIGNsYXNzPVwiaWd4LXRyZWUtbm9kZV9fdG9nZ2xlLWJ1dHRvblwiXG4gICAgICAgID5cbiAgICAgICAgXHQ8aWd4LWNpcmN1bGFyLWJhclxuICAgICAgICAgICAgXHRbYW5pbWF0ZV09XCJmYWxzZVwiXG4gICAgICAgICAgICBcdFtpbmRldGVybWluYXRlXT1cInRydWVcIlxuICAgICAgICAgICAgXHRbdGV4dFZpc2liaWxpdHldPVwiZmFsc2VcIlxuICAgICAgICBcdD5cbiAgICAgICAgXHQ8L2lneC1jaXJjdWxhci1iYXI+XG4gICAgICAgIDwvc3Bhbj5cblxuICAgICAgICA8IS0tIEl0ZW0gc2VsZWN0aW9uIC0tPlxuICAgICAgICA8ZGl2ICpuZ0lmPVwic2hvd1NlbGVjdG9yc1wiXG4gICAgICAgICAgICBjbGFzcz1cImlneC10cmVlLW5vZGVfX3NlbGVjdFwiXG4gICAgICAgICAgICAocG9pbnRlcmRvd24pPVwiJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIlxuICAgICAgICAgICAgKGNsaWNrKT1cIm9uU2VsZWN0b3JDbGljaygkZXZlbnQpXCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwic2VsZWN0TWFya2VyVGVtcGxhdGVcIj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwiaWd4LXRyZWUtbm9kZV9fY29udGVudFwiPlxuICAgICAgICAgICAgPCEtLSBHaG9zdCBjb250ZW50IC0tPlxuICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cblxuICAgIDwhLS0gIEJ1ZmZlciBlbGVtZW50IGZvciAnbW92ZSBhZnRlcicgd2hlbiBEJkQgaXMgaW1wbGVtZW50ZWQtLT5cbiAgICA8ZGl2IGNsYXNzPVwiaWd4LXRyZWUtbm9kZV9fZHJvcC1pbmRpY2F0b3JcIj5cbiAgICAgICAgPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCIgY2xhc3M9XCJpZ3gtdHJlZS1ub2RlX19zcGFjZXJcIiAqbmdGb3I9XCJsZXQgaXRlbSBvZiBbXS5jb25zdHJ1Y3RvcihsZXZlbClcIj48L3NwYW4+XG4gICAgICAgIDwhLS0gc3R5bGUgcnVsZXMgdGFyZ2V0IHRoaXMgZGl2LCBkbyBub3QgZGVsZXRlIGl0IC0tPlxuICAgICAgICA8ZGl2PjwvZGl2PlxuICAgIDwvZGl2PlxuPC9uZy10ZW1wbGF0ZT5cblxuPG5nLXRlbXBsYXRlICNkcmFnVGVtcGxhdGU+XG4gICAgPCEtLSBEcmFnIGRyb3AgZ29lcyBoZXJlXG4gICAgICAgIGlneERyb3BcbiAgICAgICAgI2Ryb3BSZWY9XCJkcm9wXCJcbiAgICAgICAgW2lneE5vZGVEcmFnXT1cInRoaXNcIlxuICAgICAgICAoZHJhZ1N0YXJ0KT1cImxvZ0Ryb3AoZHJvcFJlZilcIlxuICAgICAgICAobGVhdmUpPVwiZW1pdExlYXZlKClcIlxuICAgICAgICAoZW50ZXIpPVwiZW1pdEVudGVyKClcIiAtLT5cbiAgICA8ZGl2IGNsYXNzPVwiaWd4LXRyZWUtbm9kZV9fZHJhZy13cmFwcGVyXCI+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSAqbmdUZW1wbGF0ZU91dGxldD1cImhlYWRlclRlbXBsYXRlXCI+PC9uZy10ZW1wbGF0ZT5cbiAgICA8L2Rpdj5cbjwvbmctdGVtcGxhdGU+XG4iXX0=