import { Component, Input, Output, EventEmitter, ContentChild, Directive, TemplateRef, ContentChildren, HostBinding, Optional, Inject } from '@angular/core';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { growVerIn, growVerOut } from '../animations/grow';
import { DisplayDensityBase, DisplayDensityToken } from '../core/density';
import { IGX_TREE_COMPONENT, IgxTreeSelectionType } from './common';
import { IgxTreeNavigationService } from './tree-navigation.service';
import { IgxTreeNodeComponent } from './tree-node/tree-node.component';
import { IgxTreeSelectionService } from './tree-selection.service';
import { IgxTreeService } from './tree.service';
import * as i0 from "@angular/core";
import * as i1 from "./tree-navigation.service";
import * as i2 from "./tree-selection.service";
import * as i3 from "./tree.service";
/**
 * @hidden @internal
 * Used for templating the select marker of the tree
 */
export class IgxTreeSelectMarkerDirective {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.8", ngImport: i0, type: IgxTreeSelectMarkerDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.8", type: IgxTreeSelectMarkerDirective, isStandalone: true, selector: "[igxTreeSelectMarker]", ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.8", ngImport: i0, type: IgxTreeSelectMarkerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[igxTreeSelectMarker]',
                    standalone: true
                }]
        }] });
/**
 * @hidden @internal
 * Used for templating the expand indicator of the tree
 */
export class IgxTreeExpandIndicatorDirective {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.8", ngImport: i0, type: IgxTreeExpandIndicatorDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.8", type: IgxTreeExpandIndicatorDirective, isStandalone: true, selector: "[igxTreeExpandIndicator]", ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.8", ngImport: i0, type: IgxTreeExpandIndicatorDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[igxTreeExpandIndicator]',
                    standalone: true
                }]
        }] });
/**
 * IgxTreeComponent allows a developer to show a set of nodes in a hierarchical fashion.
 *
 * @igxModule IgxTreeModule
 * @igxKeywords tree
 * @igxTheme igx-tree-theme
 * @igxGroup Grids & Lists
 *
 * @remark
 * The Angular Tree Component allows users to represent hierarchical data in a tree-view structure,
 * maintaining parent-child relationships, as well as to define static tree-view structure without a corresponding data model.
 * Its primary purpose is to allow end-users to visualize and navigate within hierarchical data structures.
 * The Ignite UI for Angular Tree Component also provides load on demand capabilities, item activation,
 * bi-state and cascading selection of items through built-in checkboxes, built-in keyboard navigation and more.
 *
 * @example
 * ```html
 * <igx-tree>
 *   <igx-tree-node>
 *      I am a parent node 1
 *      <igx-tree-node>
 *          I am a child node 1
 *      </igx-tree-node>
 *      ...
 *   </igx-tree-node>
 *	 ...
 * </igx-tree>
 * ```
 */
export class IgxTreeComponent extends DisplayDensityBase {
    /**
     * Gets/Sets tree selection mode
     *
     * @remarks
     * By default the tree selection mode is 'None'
     * @param selectionMode: IgxTreeSelectionType
     */
    get selection() {
        return this._selection;
    }
    set selection(selectionMode) {
        this._selection = selectionMode;
        this.selectionService.clearNodesSelection();
    }
    /**
     * Returns all **root level** nodes
     *
     * ```typescript
     * const tree: IgxTree = this.tree;
     * const rootNodes: IgxTreeNodeComponent<any>[] = tree.rootNodes;
     * ```
     */
    get rootNodes() {
        return this.nodes?.filter(node => node.level === 0);
    }
    constructor(navService, selectionService, treeService, element, _displayDensityOptions) {
        super(_displayDensityOptions, element);
        this.navService = navService;
        this.selectionService = selectionService;
        this.treeService = treeService;
        this.element = element;
        this._displayDensityOptions = _displayDensityOptions;
        this.cssClass = 'igx-tree';
        /** Get/Set how the tree should handle branch expansion.
         * If set to `true`, only a single branch can be expanded at a time, collapsing all others
         *
         * ```html
         * <igx-tree [singleBranchExpand]="true">
         * ...
         * </igx-tree>
         * ```
         *
         * ```typescript
         * const tree: IgxTree = this.tree;
         * this.tree.singleBranchExpand = false;
         * ```
         */
        this.singleBranchExpand = false;
        /** Get/Set the animation settings that branches should use when expanding/collpasing.
         *
         * ```html
         * <igx-tree [animationSettings]="customAnimationSettings">
         * </igx-tree>
         * ```
         *
         * ```typescript
         * const animationSettings: ToggleAnimationSettings = {
         *      openAnimation: growVerIn,
         *      closeAnimation: growVerOut
         * };
         *
         * this.tree.animationSettings = animationSettings;
         * ```
         */
        this.animationSettings = {
            openAnimation: growVerIn,
            closeAnimation: growVerOut
        };
        /** Emitted when the node selection is changed through interaction
         *
         * ```html
         * <igx-tree (nodeSelection)="handleNodeSelection($event)">
         * </igx-tree>
         * ```
         *
         *```typescript
         * public handleNodeSelection(event: ITreeNodeSelectionEvent) {
         *  const newSelection: IgxTreeNode<any>[] = event.newSelection;
         *  const added: IgxTreeNode<any>[] = event.added;
         *  console.log("New selection will be: ", newSelection);
         *  console.log("Added nodes: ", event.added);
         * }
         *```
         */
        this.nodeSelection = new EventEmitter();
        /** Emitted when a node is expanding, before it finishes
         *
         * ```html
         * <igx-tree (nodeExpanding)="handleNodeExpanding($event)">
         * </igx-tree>
         * ```
         *
         *```typescript
         * public handleNodeExpanding(event: ITreeNodeTogglingEventArgs) {
         *  const expandedNode: IgxTreeNode<any> = event.node;
         *  if (expandedNode.disabled) {
         *      event.cancel = true;
         *  }
         * }
         *```
         */
        this.nodeExpanding = new EventEmitter();
        /** Emitted when a node is expanded, after it finishes
         *
         * ```html
         * <igx-tree (nodeExpanded)="handleNodeExpanded($event)">
         * </igx-tree>
         * ```
         *
         *```typescript
         * public handleNodeExpanded(event: ITreeNodeToggledEventArgs) {
         *  const expandedNode: IgxTreeNode<any> = event.node;
         *  console.log("Node is expanded: ", expandedNode.data);
         * }
         *```
         */
        this.nodeExpanded = new EventEmitter();
        /** Emitted when a node is collapsing, before it finishes
         *
         * ```html
         * <igx-tree (nodeCollapsing)="handleNodeCollapsing($event)">
         * </igx-tree>
         * ```
         *
         *```typescript
         * public handleNodeCollapsing(event: ITreeNodeTogglingEventArgs) {
         *  const collapsedNode: IgxTreeNode<any> = event.node;
         *  if (collapsedNode.alwaysOpen) {
         *      event.cancel = true;
         *  }
         * }
         *```
         */
        this.nodeCollapsing = new EventEmitter();
        /** Emitted when a node is collapsed, after it finishes
         *
         * @example
         * ```html
         * <igx-tree (nodeCollapsed)="handleNodeCollapsed($event)">
         * </igx-tree>
         * ```
         * ```typescript
         * public handleNodeCollapsed(event: ITreeNodeToggledEventArgs) {
         *  const collapsedNode: IgxTreeNode<any> = event.node;
         *  console.log("Node is collapsed: ", collapsedNode.data);
         * }
         * ```
         */
        this.nodeCollapsed = new EventEmitter();
        /**
         * Emitted when the active node is changed.
         *
         * @example
         * ```
         * <igx-tree (activeNodeChanged)="activeNodeChanged($event)"></igx-tree>
         * ```
         */
        this.activeNodeChanged = new EventEmitter();
        /** @hidden @internal */
        this.disabledChange = new EventEmitter();
        /**
         * Emitted when the active node is set through API
         *
         * @hidden @internal
         */
        this.activeNodeBindingChange = new EventEmitter();
        /** @hidden @internal */
        this.forceSelect = [];
        this._selection = IgxTreeSelectionType.None;
        this.destroy$ = new Subject();
        this.unsubChildren$ = new Subject();
        this._comparer = (data, node) => node.data === data;
        this.selectionService.register(this);
        this.treeService.register(this);
        this.navService.register(this);
    }
    /** @hidden @internal */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * Expands all of the passed nodes.
     * If no nodes are passed, expands ALL nodes
     *
     * @param nodes nodes to be expanded
     *
     * ```typescript
     * const targetNodes: IgxTreeNode<any> = this.tree.findNodes(true, (_data: any, node: IgxTreeNode<any>) => node.data.expandable);
     * tree.expandAll(nodes);
     * ```
     */
    expandAll(nodes) {
        nodes = nodes || this.nodes.toArray();
        nodes.forEach(e => e.expanded = true);
    }
    /**
     * Collapses all of the passed nodes.
     * If no nodes are passed, collapses ALL nodes
     *
     * @param nodes nodes to be collapsed
     *
     * ```typescript
     * const targetNodes: IgxTreeNode<any> = this.tree.findNodes(true, (_data: any, node: IgxTreeNode<any>) => node.data.collapsible);
     * tree.collapseAll(nodes);
     * ```
     */
    collapseAll(nodes) {
        nodes = nodes || this.nodes.toArray();
        nodes.forEach(e => e.expanded = false);
    }
    /**
     * Deselect all nodes if the nodes collection is empty. Otherwise, deselect the nodes in the nodes collection.
     *
     * @example
     * ```typescript
     *  const arr = [
     *      this.tree.nodes.toArray()[0],
     *      this.tree.nodes.toArray()[1]
     *  ];
     *  this.tree.deselectAll(arr);
     * ```
     * @param nodes: IgxTreeNodeComponent<any>[]
     */
    deselectAll(nodes) {
        this.selectionService.deselectNodesWithNoEvent(nodes);
    }
    /**
     * Returns all of the nodes that match the passed searchTerm.
     * Accepts a custom comparer function for evaluating the search term against the nodes.
     *
     * @remark
     * Default search compares the passed `searchTerm` against the node's `data` Input.
     * When using `findNodes` w/o a `comparer`, make sure all nodes have `data` passed.
     *
     * @param searchTerm The data of the searched node
     * @param comparer A custom comparer function that evaluates the passed `searchTerm` against all nodes.
     * @returns Array of nodes that match the search. `null` if no nodes are found.
     *
     * ```html
     * <igx-tree>
     *     <igx-tree-node *ngFor="let node of data" [data]="node">
     *          {{ node.label }}
     *     </igx-tree-node>
     * </igx-tree>
     * ```
     *
     * ```typescript
     * public data: DataEntry[] = FETCHED_DATA;
     * ...
     * const matchedNodes: IgxTreeNode<DataEntry>[] = this.tree.findNodes<DataEntry>(searchTerm: data[5]);
     * ```
     *
     * Using a custom comparer
     * ```typescript
     * public data: DataEntry[] = FETCHED_DATA;
     * ...
     * const comparer: IgxTreeSearchResolver = (data: any, node: IgxTreeNode<DataEntry>) {
     *      return node.data.index % 2 === 0;
     * }
     * const evenIndexNodes: IgxTreeNode<DataEntry>[] = this.tree.findNodes<DataEntry>(null, comparer);
     * ```
     */
    findNodes(searchTerm, comparer) {
        const compareFunc = comparer || this._comparer;
        const results = this.nodes.filter(node => compareFunc(searchTerm, node));
        return results?.length === 0 ? null : results;
    }
    /** @hidden @internal */
    handleKeydown(event) {
        this.navService.handleKeydown(event);
    }
    /** @hidden @internal */
    ngOnInit() {
        super.ngOnInit();
        this.disabledChange.pipe(takeUntil(this.destroy$)).subscribe((e) => {
            this.navService.update_disabled_cache(e);
        });
        this.activeNodeBindingChange.pipe(takeUntil(this.destroy$)).subscribe((node) => {
            this.expandToNode(this.navService.activeNode);
            this.scrollNodeIntoView(node?.header?.nativeElement);
        });
        this.densityChanged.pipe(takeUntil(this.destroy$)).subscribe(() => {
            requestAnimationFrame(() => {
                this.scrollNodeIntoView(this.navService.activeNode?.header.nativeElement);
            });
        });
        this.subToCollapsing();
    }
    /** @hidden @internal */
    ngAfterViewInit() {
        this.nodes.changes.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.subToChanges();
        });
        this.scrollNodeIntoView(this.navService.activeNode?.header?.nativeElement);
        this.subToChanges();
    }
    /** @hidden @internal */
    ngOnDestroy() {
        this.unsubChildren$.next();
        this.unsubChildren$.complete();
        this.destroy$.next();
        this.destroy$.complete();
    }
    expandToNode(node) {
        if (node && node.parentNode) {
            node.path.forEach(n => {
                if (n !== node && !n.expanded) {
                    n.expanded = true;
                }
            });
        }
    }
    subToCollapsing() {
        this.nodeCollapsing.pipe(takeUntil(this.destroy$)).subscribe(event => {
            if (event.cancel) {
                return;
            }
            this.navService.update_visible_cache(event.node, false);
        });
        this.nodeExpanding.pipe(takeUntil(this.destroy$)).subscribe(event => {
            if (event.cancel) {
                return;
            }
            this.navService.update_visible_cache(event.node, true);
        });
    }
    subToChanges() {
        this.unsubChildren$.next();
        const toBeSelected = [...this.forceSelect];
        requestAnimationFrame(() => {
            this.selectionService.selectNodesWithNoEvent(toBeSelected);
        });
        this.forceSelect = [];
        this.nodes.forEach(node => {
            node.expandedChange.pipe(takeUntil(this.unsubChildren$)).subscribe(nodeState => {
                this.navService.update_visible_cache(node, nodeState);
            });
            node.closeAnimationDone.pipe(takeUntil(this.unsubChildren$)).subscribe(() => {
                const targetElement = this.navService.focusedNode?.header.nativeElement;
                this.scrollNodeIntoView(targetElement);
            });
            node.openAnimationDone.pipe(takeUntil(this.unsubChildren$)).subscribe(() => {
                const targetElement = this.navService.focusedNode?.header.nativeElement;
                this.scrollNodeIntoView(targetElement);
            });
        });
        this.navService.init_invisible_cache();
    }
    scrollNodeIntoView(el) {
        if (!el) {
            return;
        }
        const nodeRect = el.getBoundingClientRect();
        const treeRect = this.nativeElement.getBoundingClientRect();
        const topOffset = treeRect.top > nodeRect.top ? nodeRect.top - treeRect.top : 0;
        const bottomOffset = treeRect.bottom < nodeRect.bottom ? nodeRect.bottom - treeRect.bottom : 0;
        const shouldScroll = !!topOffset || !!bottomOffset;
        if (shouldScroll && this.nativeElement.scrollHeight > this.nativeElement.clientHeight) {
            // this.nativeElement.scrollTop = nodeRect.y - treeRect.y - nodeRect.height;
            this.nativeElement.scrollTop =
                this.nativeElement.scrollTop + bottomOffset + topOffset + (topOffset ? -1 : +1) * nodeRect.height;
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.8", ngImport: i0, type: IgxTreeComponent, deps: [{ token: i1.IgxTreeNavigationService }, { token: i2.IgxTreeSelectionService }, { token: i3.IgxTreeService }, { token: i0.ElementRef }, { token: DisplayDensityToken, optional: true }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.8", type: IgxTreeComponent, isStandalone: true, selector: "igx-tree", inputs: { selection: "selection", singleBranchExpand: "singleBranchExpand", animationSettings: "animationSettings" }, outputs: { nodeSelection: "nodeSelection", nodeExpanding: "nodeExpanding", nodeExpanded: "nodeExpanded", nodeCollapsing: "nodeCollapsing", nodeCollapsed: "nodeCollapsed", activeNodeChanged: "activeNodeChanged" }, host: { properties: { "class.igx-tree": "this.cssClass" } }, providers: [
            IgxTreeService,
            IgxTreeSelectionService,
            IgxTreeNavigationService,
            { provide: IGX_TREE_COMPONENT, useExisting: IgxTreeComponent },
        ], queries: [{ propertyName: "expandIndicator", first: true, predicate: IgxTreeExpandIndicatorDirective, descendants: true, read: TemplateRef }, { propertyName: "nodes", predicate: IgxTreeNodeComponent, descendants: true }], usesInheritance: true, ngImport: i0, template: "<div class=\"igx-tree__root\" role=\"tree\" (keydown)=\"handleKeydown($event)\">\n    <ng-content select=\"igx-tree-node\"></ng-content>\n</div>\n" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.8", ngImport: i0, type: IgxTreeComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igx-tree', providers: [
                        IgxTreeService,
                        IgxTreeSelectionService,
                        IgxTreeNavigationService,
                        { provide: IGX_TREE_COMPONENT, useExisting: IgxTreeComponent },
                    ], standalone: true, template: "<div class=\"igx-tree__root\" role=\"tree\" (keydown)=\"handleKeydown($event)\">\n    <ng-content select=\"igx-tree-node\"></ng-content>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i1.IgxTreeNavigationService }, { type: i2.IgxTreeSelectionService }, { type: i3.IgxTreeService }, { type: i0.ElementRef }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [DisplayDensityToken]
                }] }]; }, propDecorators: { cssClass: [{
                type: HostBinding,
                args: ['class.igx-tree']
            }], selection: [{
                type: Input
            }], singleBranchExpand: [{
                type: Input
            }], animationSettings: [{
                type: Input
            }], nodeSelection: [{
                type: Output
            }], nodeExpanding: [{
                type: Output
            }], nodeExpanded: [{
                type: Output
            }], nodeCollapsing: [{
                type: Output
            }], nodeCollapsed: [{
                type: Output
            }], activeNodeChanged: [{
                type: Output
            }], expandIndicator: [{
                type: ContentChild,
                args: [IgxTreeExpandIndicatorDirective, { read: TemplateRef }]
            }], nodes: [{
                type: ContentChildren,
                args: [IgxTreeNodeComponent, { descendants: true }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvdHJlZS90cmVlLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi90cmVlL3RyZWUuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNILFNBQVMsRUFBYSxLQUFLLEVBQUUsTUFBTSxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsU0FBUyxFQUMxRSxXQUFXLEVBQXlCLGVBQWUsRUFBYSxXQUFXLEVBQWMsUUFBUSxFQUFFLE1BQU0sRUFDNUcsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMvQixPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFM0MsT0FBTyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUMzRCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsbUJBQW1CLEVBQTBCLE1BQU0saUJBQWlCLENBQUM7QUFFbEcsT0FBTyxFQUNILGtCQUFrQixFQUFFLG9CQUFvQixFQUUzQyxNQUFNLFVBQVUsQ0FBQztBQUNsQixPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUNyRSxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUN2RSxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUNuRSxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7Ozs7O0FBRWhEOzs7R0FHRztBQUtILE1BQU0sT0FBTyw0QkFBNEI7OEdBQTVCLDRCQUE0QjtrR0FBNUIsNEJBQTRCOzsyRkFBNUIsNEJBQTRCO2tCQUp4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QkFEeEIsS0FBSztnQkFvQkMsaUJBQWlCO3NCQUR2QixLQUFLO2dCQXVCQyxhQUFhO3NCQURuQixNQUFNO2dCQW9CQSxhQUFhO3NCQURuQixNQUFNO2dCQWtCQSxZQUFZO3NCQURsQixNQUFNO2dCQW9CQSxjQUFjO3NCQURwQixNQUFNO2dCQWtCQSxhQUFhO3NCQURuQixNQUFNO2dCQVlBLGlCQUFpQjtzQkFEdkIsTUFBTTtnQkFjQSxlQUFlO3NCQURyQixZQUFZO3VCQUFDLCtCQUErQixFQUFFLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRTtnQkFLN0QsS0FBSztzQkFEWCxlQUFlO3VCQUFDLG9CQUFvQixFQUFFLEVBQUUsV0FBVyxFQUFFLElBQUksRUFBRSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQ29tcG9uZW50LCBRdWVyeUxpc3QsIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgQ29udGVudENoaWxkLCBEaXJlY3RpdmUsXG4gICAgVGVtcGxhdGVSZWYsIE9uSW5pdCwgQWZ0ZXJWaWV3SW5pdCwgQ29udGVudENoaWxkcmVuLCBPbkRlc3Ryb3ksIEhvc3RCaW5kaW5nLCBFbGVtZW50UmVmLCBPcHRpb25hbCwgSW5qZWN0XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IGdyb3dWZXJJbiwgZ3Jvd1Zlck91dCB9IGZyb20gJy4uL2FuaW1hdGlvbnMvZ3Jvdyc7XG5pbXBvcnQgeyBEaXNwbGF5RGVuc2l0eUJhc2UsIERpc3BsYXlEZW5zaXR5VG9rZW4sIElEaXNwbGF5RGVuc2l0eU9wdGlvbnMgfSBmcm9tICcuLi9jb3JlL2RlbnNpdHknO1xuaW1wb3J0IHsgVG9nZ2xlQW5pbWF0aW9uU2V0dGluZ3MgfSBmcm9tICcuLi9leHBhbnNpb24tcGFuZWwvdG9nZ2xlLWFuaW1hdGlvbi1jb21wb25lbnQnO1xuaW1wb3J0IHtcbiAgICBJR1hfVFJFRV9DT01QT05FTlQsIElneFRyZWVTZWxlY3Rpb25UeXBlLCBJZ3hUcmVlLCBJVHJlZU5vZGVUb2dnbGVkRXZlbnRBcmdzLFxuICAgIElUcmVlTm9kZVRvZ2dsaW5nRXZlbnRBcmdzLCBJVHJlZU5vZGVTZWxlY3Rpb25FdmVudCwgSWd4VHJlZU5vZGUsIElneFRyZWVTZWFyY2hSZXNvbHZlclxufSBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQgeyBJZ3hUcmVlTmF2aWdhdGlvblNlcnZpY2UgfSBmcm9tICcuL3RyZWUtbmF2aWdhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IElneFRyZWVOb2RlQ29tcG9uZW50IH0gZnJvbSAnLi90cmVlLW5vZGUvdHJlZS1ub2RlLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hUcmVlU2VsZWN0aW9uU2VydmljZSB9IGZyb20gJy4vdHJlZS1zZWxlY3Rpb24uc2VydmljZSc7XG5pbXBvcnQgeyBJZ3hUcmVlU2VydmljZSB9IGZyb20gJy4vdHJlZS5zZXJ2aWNlJztcblxuLyoqXG4gKiBAaGlkZGVuIEBpbnRlcm5hbFxuICogVXNlZCBmb3IgdGVtcGxhdGluZyB0aGUgc2VsZWN0IG1hcmtlciBvZiB0aGUgdHJlZVxuICovXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1tpZ3hUcmVlU2VsZWN0TWFya2VyXScsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hUcmVlU2VsZWN0TWFya2VyRGlyZWN0aXZlIHtcbn1cblxuLyoqXG4gKiBAaGlkZGVuIEBpbnRlcm5hbFxuICogVXNlZCBmb3IgdGVtcGxhdGluZyB0aGUgZXhwYW5kIGluZGljYXRvciBvZiB0aGUgdHJlZVxuICovXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1tpZ3hUcmVlRXhwYW5kSW5kaWNhdG9yXScsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hUcmVlRXhwYW5kSW5kaWNhdG9yRGlyZWN0aXZlIHtcbn1cblxuLyoqXG4gKiBJZ3hUcmVlQ29tcG9uZW50IGFsbG93cyBhIGRldmVsb3BlciB0byBzaG93IGEgc2V0IG9mIG5vZGVzIGluIGEgaGllcmFyY2hpY2FsIGZhc2hpb24uXG4gKlxuICogQGlneE1vZHVsZSBJZ3hUcmVlTW9kdWxlXG4gKiBAaWd4S2V5d29yZHMgdHJlZVxuICogQGlneFRoZW1lIGlneC10cmVlLXRoZW1lXG4gKiBAaWd4R3JvdXAgR3JpZHMgJiBMaXN0c1xuICpcbiAqIEByZW1hcmtcbiAqIFRoZSBBbmd1bGFyIFRyZWUgQ29tcG9uZW50IGFsbG93cyB1c2VycyB0byByZXByZXNlbnQgaGllcmFyY2hpY2FsIGRhdGEgaW4gYSB0cmVlLXZpZXcgc3RydWN0dXJlLFxuICogbWFpbnRhaW5pbmcgcGFyZW50LWNoaWxkIHJlbGF0aW9uc2hpcHMsIGFzIHdlbGwgYXMgdG8gZGVmaW5lIHN0YXRpYyB0cmVlLXZpZXcgc3RydWN0dXJlIHdpdGhvdXQgYSBjb3JyZXNwb25kaW5nIGRhdGEgbW9kZWwuXG4gKiBJdHMgcHJpbWFyeSBwdXJwb3NlIGlzIHRvIGFsbG93IGVuZC11c2VycyB0byB2aXN1YWxpemUgYW5kIG5hdmlnYXRlIHdpdGhpbiBoaWVyYXJjaGljYWwgZGF0YSBzdHJ1Y3R1cmVzLlxuICogVGhlIElnbml0ZSBVSSBmb3IgQW5ndWxhciBUcmVlIENvbXBvbmVudCBhbHNvIHByb3ZpZGVzIGxvYWQgb24gZGVtYW5kIGNhcGFiaWxpdGllcywgaXRlbSBhY3RpdmF0aW9uLFxuICogYmktc3RhdGUgYW5kIGNhc2NhZGluZyBzZWxlY3Rpb24gb2YgaXRlbXMgdGhyb3VnaCBidWlsdC1pbiBjaGVja2JveGVzLCBidWlsdC1pbiBrZXlib2FyZCBuYXZpZ2F0aW9uIGFuZCBtb3JlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBodG1sXG4gKiA8aWd4LXRyZWU+XG4gKiAgIDxpZ3gtdHJlZS1ub2RlPlxuICogICAgICBJIGFtIGEgcGFyZW50IG5vZGUgMVxuICogICAgICA8aWd4LXRyZWUtbm9kZT5cbiAqICAgICAgICAgIEkgYW0gYSBjaGlsZCBub2RlIDFcbiAqICAgICAgPC9pZ3gtdHJlZS1ub2RlPlxuICogICAgICAuLi5cbiAqICAgPC9pZ3gtdHJlZS1ub2RlPlxuICpcdCAuLi5cbiAqIDwvaWd4LXRyZWU+XG4gKiBgYGBcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdpZ3gtdHJlZScsXG4gICAgdGVtcGxhdGVVcmw6ICd0cmVlLmNvbXBvbmVudC5odG1sJyxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgSWd4VHJlZVNlcnZpY2UsXG4gICAgICAgIElneFRyZWVTZWxlY3Rpb25TZXJ2aWNlLFxuICAgICAgICBJZ3hUcmVlTmF2aWdhdGlvblNlcnZpY2UsXG4gICAgICAgIHsgcHJvdmlkZTogSUdYX1RSRUVfQ09NUE9ORU5ULCB1c2VFeGlzdGluZzogSWd4VHJlZUNvbXBvbmVudCB9LFxuICAgIF0sXG4gICAgc3RhbmRhbG9uZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hUcmVlQ29tcG9uZW50IGV4dGVuZHMgRGlzcGxheURlbnNpdHlCYXNlIGltcGxlbWVudHMgSWd4VHJlZSwgT25Jbml0LCBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtdHJlZScpXG4gICAgcHVibGljIGNzc0NsYXNzID0gJ2lneC10cmVlJztcblxuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB0cmVlIHNlbGVjdGlvbiBtb2RlXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIEJ5IGRlZmF1bHQgdGhlIHRyZWUgc2VsZWN0aW9uIG1vZGUgaXMgJ05vbmUnXG4gICAgICogQHBhcmFtIHNlbGVjdGlvbk1vZGU6IElneFRyZWVTZWxlY3Rpb25UeXBlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IHNlbGVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGlvbjtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IHNlbGVjdGlvbihzZWxlY3Rpb25Nb2RlOiBJZ3hUcmVlU2VsZWN0aW9uVHlwZSkge1xuICAgICAgICB0aGlzLl9zZWxlY3Rpb24gPSBzZWxlY3Rpb25Nb2RlO1xuICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UuY2xlYXJOb2Rlc1NlbGVjdGlvbigpO1xuICAgIH1cblxuICAgIC8qKiBHZXQvU2V0IGhvdyB0aGUgdHJlZSBzaG91bGQgaGFuZGxlIGJyYW5jaCBleHBhbnNpb24uXG4gICAgICogSWYgc2V0IHRvIGB0cnVlYCwgb25seSBhIHNpbmdsZSBicmFuY2ggY2FuIGJlIGV4cGFuZGVkIGF0IGEgdGltZSwgY29sbGFwc2luZyBhbGwgb3RoZXJzXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC10cmVlIFtzaW5nbGVCcmFuY2hFeHBhbmRdPVwidHJ1ZVwiPlxuICAgICAqIC4uLlxuICAgICAqIDwvaWd4LXRyZWU+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgdHJlZTogSWd4VHJlZSA9IHRoaXMudHJlZTtcbiAgICAgKiB0aGlzLnRyZWUuc2luZ2xlQnJhbmNoRXhwYW5kID0gZmFsc2U7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2luZ2xlQnJhbmNoRXhwYW5kID0gZmFsc2U7XG5cbiAgICAvKiogR2V0L1NldCB0aGUgYW5pbWF0aW9uIHNldHRpbmdzIHRoYXQgYnJhbmNoZXMgc2hvdWxkIHVzZSB3aGVuIGV4cGFuZGluZy9jb2xscGFzaW5nLlxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdHJlZSBbYW5pbWF0aW9uU2V0dGluZ3NdPVwiY3VzdG9tQW5pbWF0aW9uU2V0dGluZ3NcIj5cbiAgICAgKiA8L2lneC10cmVlPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGFuaW1hdGlvblNldHRpbmdzOiBUb2dnbGVBbmltYXRpb25TZXR0aW5ncyA9IHtcbiAgICAgKiAgICAgIG9wZW5BbmltYXRpb246IGdyb3dWZXJJbixcbiAgICAgKiAgICAgIGNsb3NlQW5pbWF0aW9uOiBncm93VmVyT3V0XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHRoaXMudHJlZS5hbmltYXRpb25TZXR0aW5ncyA9IGFuaW1hdGlvblNldHRpbmdzO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGFuaW1hdGlvblNldHRpbmdzOiBUb2dnbGVBbmltYXRpb25TZXR0aW5ncyA9IHtcbiAgICAgICAgb3BlbkFuaW1hdGlvbjogZ3Jvd1ZlckluLFxuICAgICAgICBjbG9zZUFuaW1hdGlvbjogZ3Jvd1Zlck91dFxuICAgIH07XG5cbiAgICAvKiogRW1pdHRlZCB3aGVuIHRoZSBub2RlIHNlbGVjdGlvbiBpcyBjaGFuZ2VkIHRocm91Z2ggaW50ZXJhY3Rpb25cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRyZWUgKG5vZGVTZWxlY3Rpb24pPVwiaGFuZGxlTm9kZVNlbGVjdGlvbigkZXZlbnQpXCI+XG4gICAgICogPC9pZ3gtdHJlZT5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBoYW5kbGVOb2RlU2VsZWN0aW9uKGV2ZW50OiBJVHJlZU5vZGVTZWxlY3Rpb25FdmVudCkge1xuICAgICAqICBjb25zdCBuZXdTZWxlY3Rpb246IElneFRyZWVOb2RlPGFueT5bXSA9IGV2ZW50Lm5ld1NlbGVjdGlvbjtcbiAgICAgKiAgY29uc3QgYWRkZWQ6IElneFRyZWVOb2RlPGFueT5bXSA9IGV2ZW50LmFkZGVkO1xuICAgICAqICBjb25zb2xlLmxvZyhcIk5ldyBzZWxlY3Rpb24gd2lsbCBiZTogXCIsIG5ld1NlbGVjdGlvbik7XG4gICAgICogIGNvbnNvbGUubG9nKFwiQWRkZWQgbm9kZXM6IFwiLCBldmVudC5hZGRlZCk7XG4gICAgICogfVxuICAgICAqYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG5vZGVTZWxlY3Rpb24gPSBuZXcgRXZlbnRFbWl0dGVyPElUcmVlTm9kZVNlbGVjdGlvbkV2ZW50PigpO1xuXG4gICAgLyoqIEVtaXR0ZWQgd2hlbiBhIG5vZGUgaXMgZXhwYW5kaW5nLCBiZWZvcmUgaXQgZmluaXNoZXNcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRyZWUgKG5vZGVFeHBhbmRpbmcpPVwiaGFuZGxlTm9kZUV4cGFuZGluZygkZXZlbnQpXCI+XG4gICAgICogPC9pZ3gtdHJlZT5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBoYW5kbGVOb2RlRXhwYW5kaW5nKGV2ZW50OiBJVHJlZU5vZGVUb2dnbGluZ0V2ZW50QXJncykge1xuICAgICAqICBjb25zdCBleHBhbmRlZE5vZGU6IElneFRyZWVOb2RlPGFueT4gPSBldmVudC5ub2RlO1xuICAgICAqICBpZiAoZXhwYW5kZWROb2RlLmRpc2FibGVkKSB7XG4gICAgICogICAgICBldmVudC5jYW5jZWwgPSB0cnVlO1xuICAgICAqICB9XG4gICAgICogfVxuICAgICAqYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG5vZGVFeHBhbmRpbmcgPSBuZXcgRXZlbnRFbWl0dGVyPElUcmVlTm9kZVRvZ2dsaW5nRXZlbnRBcmdzPigpO1xuXG4gICAgLyoqIEVtaXR0ZWQgd2hlbiBhIG5vZGUgaXMgZXhwYW5kZWQsIGFmdGVyIGl0IGZpbmlzaGVzXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC10cmVlIChub2RlRXhwYW5kZWQpPVwiaGFuZGxlTm9kZUV4cGFuZGVkKCRldmVudClcIj5cbiAgICAgKiA8L2lneC10cmVlPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIGhhbmRsZU5vZGVFeHBhbmRlZChldmVudDogSVRyZWVOb2RlVG9nZ2xlZEV2ZW50QXJncykge1xuICAgICAqICBjb25zdCBleHBhbmRlZE5vZGU6IElneFRyZWVOb2RlPGFueT4gPSBldmVudC5ub2RlO1xuICAgICAqICBjb25zb2xlLmxvZyhcIk5vZGUgaXMgZXhwYW5kZWQ6IFwiLCBleHBhbmRlZE5vZGUuZGF0YSk7XG4gICAgICogfVxuICAgICAqYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG5vZGVFeHBhbmRlZCA9IG5ldyBFdmVudEVtaXR0ZXI8SVRyZWVOb2RlVG9nZ2xlZEV2ZW50QXJncz4oKTtcblxuICAgIC8qKiBFbWl0dGVkIHdoZW4gYSBub2RlIGlzIGNvbGxhcHNpbmcsIGJlZm9yZSBpdCBmaW5pc2hlc1xuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdHJlZSAobm9kZUNvbGxhcHNpbmcpPVwiaGFuZGxlTm9kZUNvbGxhcHNpbmcoJGV2ZW50KVwiPlxuICAgICAqIDwvaWd4LXRyZWU+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgaGFuZGxlTm9kZUNvbGxhcHNpbmcoZXZlbnQ6IElUcmVlTm9kZVRvZ2dsaW5nRXZlbnRBcmdzKSB7XG4gICAgICogIGNvbnN0IGNvbGxhcHNlZE5vZGU6IElneFRyZWVOb2RlPGFueT4gPSBldmVudC5ub2RlO1xuICAgICAqICBpZiAoY29sbGFwc2VkTm9kZS5hbHdheXNPcGVuKSB7XG4gICAgICogICAgICBldmVudC5jYW5jZWwgPSB0cnVlO1xuICAgICAqICB9XG4gICAgICogfVxuICAgICAqYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG5vZGVDb2xsYXBzaW5nID0gbmV3IEV2ZW50RW1pdHRlcjxJVHJlZU5vZGVUb2dnbGluZ0V2ZW50QXJncz4oKTtcblxuICAgIC8qKiBFbWl0dGVkIHdoZW4gYSBub2RlIGlzIGNvbGxhcHNlZCwgYWZ0ZXIgaXQgZmluaXNoZXNcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdHJlZSAobm9kZUNvbGxhcHNlZCk9XCJoYW5kbGVOb2RlQ29sbGFwc2VkKCRldmVudClcIj5cbiAgICAgKiA8L2lneC10cmVlPlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgaGFuZGxlTm9kZUNvbGxhcHNlZChldmVudDogSVRyZWVOb2RlVG9nZ2xlZEV2ZW50QXJncykge1xuICAgICAqICBjb25zdCBjb2xsYXBzZWROb2RlOiBJZ3hUcmVlTm9kZTxhbnk+ID0gZXZlbnQubm9kZTtcbiAgICAgKiAgY29uc29sZS5sb2coXCJOb2RlIGlzIGNvbGxhcHNlZDogXCIsIGNvbGxhcHNlZE5vZGUuZGF0YSk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBub2RlQ29sbGFwc2VkID0gbmV3IEV2ZW50RW1pdHRlcjxJVHJlZU5vZGVUb2dnbGVkRXZlbnRBcmdzPigpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIHRoZSBhY3RpdmUgbm9kZSBpcyBjaGFuZ2VkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBcbiAgICAgKiA8aWd4LXRyZWUgKGFjdGl2ZU5vZGVDaGFuZ2VkKT1cImFjdGl2ZU5vZGVDaGFuZ2VkKCRldmVudClcIj48L2lneC10cmVlPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBhY3RpdmVOb2RlQ2hhbmdlZCA9IG5ldyBFdmVudEVtaXR0ZXI8SWd4VHJlZU5vZGU8YW55Pj4oKTtcblxuICAgIC8qKlxuICAgICAqIEEgY3VzdG9tIHRlbXBsYXRlIHRvIGJlIHVzZWQgZm9yIHRoZSBleHBhbmQgaW5kaWNhdG9yIG9mIG5vZGVzXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdHJlZT5cbiAgICAgKiAgPG5nLXRlbXBsYXRlIGlneFRyZWVFeHBhbmRJbmRpY2F0b3IgbGV0LWV4cGFuZGVkPlxuICAgICAqICAgICAgPGlneC1pY29uPnt7IGV4cGFuZGVkID8gXCJjbG9zZV9mdWxsc2NyZWVuXCI6IFwib3Blbl9pbl9mdWxsXCJ9fTwvaWd4LWljb24+XG4gICAgICogIDwvbmctdGVtcGxhdGU+XG4gICAgICogPC9pZ3gtdHJlZT5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKElneFRyZWVFeHBhbmRJbmRpY2F0b3JEaXJlY3RpdmUsIHsgcmVhZDogVGVtcGxhdGVSZWYgfSlcbiAgICBwdWJsaWMgZXhwYW5kSW5kaWNhdG9yOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgQENvbnRlbnRDaGlsZHJlbihJZ3hUcmVlTm9kZUNvbXBvbmVudCwgeyBkZXNjZW5kYW50czogdHJ1ZSB9KVxuICAgIHB1YmxpYyBub2RlczogUXVlcnlMaXN0PElneFRyZWVOb2RlQ29tcG9uZW50PGFueT4+O1xuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIGRpc2FibGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxJZ3hUcmVlTm9kZTxhbnk+PigpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgKipyb290IGxldmVsKiogbm9kZXNcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCB0cmVlOiBJZ3hUcmVlID0gdGhpcy50cmVlO1xuICAgICAqIGNvbnN0IHJvb3ROb2RlczogSWd4VHJlZU5vZGVDb21wb25lbnQ8YW55PltdID0gdHJlZS5yb290Tm9kZXM7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCByb290Tm9kZXMoKTogSWd4VHJlZU5vZGVDb21wb25lbnQ8YW55PltdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXM/LmZpbHRlcihub2RlID0+IG5vZGUubGV2ZWwgPT09IDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiB0aGUgYWN0aXZlIG5vZGUgaXMgc2V0IHRocm91Z2ggQVBJXG4gICAgICpcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBhY3RpdmVOb2RlQmluZGluZ0NoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8SWd4VHJlZU5vZGU8YW55Pj4oKTtcblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBmb3JjZVNlbGVjdCA9IFtdO1xuXG4gICAgcHJpdmF0ZSBfc2VsZWN0aW9uOiBJZ3hUcmVlU2VsZWN0aW9uVHlwZSA9IElneFRyZWVTZWxlY3Rpb25UeXBlLk5vbmU7XG4gICAgcHJpdmF0ZSBkZXN0cm95JCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG4gICAgcHJpdmF0ZSB1bnN1YkNoaWxkcmVuJCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBuYXZTZXJ2aWNlOiBJZ3hUcmVlTmF2aWdhdGlvblNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgc2VsZWN0aW9uU2VydmljZTogSWd4VHJlZVNlbGVjdGlvblNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgdHJlZVNlcnZpY2U6IElneFRyZWVTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIGVsZW1lbnQ6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+LFxuICAgICAgICBAT3B0aW9uYWwoKSBASW5qZWN0KERpc3BsYXlEZW5zaXR5VG9rZW4pIHByb3RlY3RlZCBfZGlzcGxheURlbnNpdHlPcHRpb25zPzogSURpc3BsYXlEZW5zaXR5T3B0aW9ucykge1xuICAgICAgICBzdXBlcihfZGlzcGxheURlbnNpdHlPcHRpb25zLCBlbGVtZW50KTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICB0aGlzLnRyZWVTZXJ2aWNlLnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICB0aGlzLm5hdlNlcnZpY2UucmVnaXN0ZXIodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIGdldCBuYXRpdmVFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhwYW5kcyBhbGwgb2YgdGhlIHBhc3NlZCBub2Rlcy5cbiAgICAgKiBJZiBubyBub2RlcyBhcmUgcGFzc2VkLCBleHBhbmRzIEFMTCBub2Rlc1xuICAgICAqXG4gICAgICogQHBhcmFtIG5vZGVzIG5vZGVzIHRvIGJlIGV4cGFuZGVkXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgdGFyZ2V0Tm9kZXM6IElneFRyZWVOb2RlPGFueT4gPSB0aGlzLnRyZWUuZmluZE5vZGVzKHRydWUsIChfZGF0YTogYW55LCBub2RlOiBJZ3hUcmVlTm9kZTxhbnk+KSA9PiBub2RlLmRhdGEuZXhwYW5kYWJsZSk7XG4gICAgICogdHJlZS5leHBhbmRBbGwobm9kZXMpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBleHBhbmRBbGwobm9kZXM/OiBJZ3hUcmVlTm9kZTxhbnk+W10pIHtcbiAgICAgICAgbm9kZXMgPSBub2RlcyB8fCB0aGlzLm5vZGVzLnRvQXJyYXkoKTtcbiAgICAgICAgbm9kZXMuZm9yRWFjaChlID0+IGUuZXhwYW5kZWQgPSB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb2xsYXBzZXMgYWxsIG9mIHRoZSBwYXNzZWQgbm9kZXMuXG4gICAgICogSWYgbm8gbm9kZXMgYXJlIHBhc3NlZCwgY29sbGFwc2VzIEFMTCBub2Rlc1xuICAgICAqXG4gICAgICogQHBhcmFtIG5vZGVzIG5vZGVzIHRvIGJlIGNvbGxhcHNlZFxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHRhcmdldE5vZGVzOiBJZ3hUcmVlTm9kZTxhbnk+ID0gdGhpcy50cmVlLmZpbmROb2Rlcyh0cnVlLCAoX2RhdGE6IGFueSwgbm9kZTogSWd4VHJlZU5vZGU8YW55PikgPT4gbm9kZS5kYXRhLmNvbGxhcHNpYmxlKTtcbiAgICAgKiB0cmVlLmNvbGxhcHNlQWxsKG5vZGVzKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgY29sbGFwc2VBbGwobm9kZXM/OiBJZ3hUcmVlTm9kZTxhbnk+W10pIHtcbiAgICAgICAgbm9kZXMgPSBub2RlcyB8fCB0aGlzLm5vZGVzLnRvQXJyYXkoKTtcbiAgICAgICAgbm9kZXMuZm9yRWFjaChlID0+IGUuZXhwYW5kZWQgPSBmYWxzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzZWxlY3QgYWxsIG5vZGVzIGlmIHRoZSBub2RlcyBjb2xsZWN0aW9uIGlzIGVtcHR5LiBPdGhlcndpc2UsIGRlc2VsZWN0IHRoZSBub2RlcyBpbiB0aGUgbm9kZXMgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqICBjb25zdCBhcnIgPSBbXG4gICAgICogICAgICB0aGlzLnRyZWUubm9kZXMudG9BcnJheSgpWzBdLFxuICAgICAqICAgICAgdGhpcy50cmVlLm5vZGVzLnRvQXJyYXkoKVsxXVxuICAgICAqICBdO1xuICAgICAqICB0aGlzLnRyZWUuZGVzZWxlY3RBbGwoYXJyKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gbm9kZXM6IElneFRyZWVOb2RlQ29tcG9uZW50PGFueT5bXVxuICAgICAqL1xuICAgIHB1YmxpYyBkZXNlbGVjdEFsbChub2Rlcz86IElneFRyZWVOb2RlQ29tcG9uZW50PGFueT5bXSkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UuZGVzZWxlY3ROb2Rlc1dpdGhOb0V2ZW50KG5vZGVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBvZiB0aGUgbm9kZXMgdGhhdCBtYXRjaCB0aGUgcGFzc2VkIHNlYXJjaFRlcm0uXG4gICAgICogQWNjZXB0cyBhIGN1c3RvbSBjb21wYXJlciBmdW5jdGlvbiBmb3IgZXZhbHVhdGluZyB0aGUgc2VhcmNoIHRlcm0gYWdhaW5zdCB0aGUgbm9kZXMuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrXG4gICAgICogRGVmYXVsdCBzZWFyY2ggY29tcGFyZXMgdGhlIHBhc3NlZCBgc2VhcmNoVGVybWAgYWdhaW5zdCB0aGUgbm9kZSdzIGBkYXRhYCBJbnB1dC5cbiAgICAgKiBXaGVuIHVzaW5nIGBmaW5kTm9kZXNgIHcvbyBhIGBjb21wYXJlcmAsIG1ha2Ugc3VyZSBhbGwgbm9kZXMgaGF2ZSBgZGF0YWAgcGFzc2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNlYXJjaFRlcm0gVGhlIGRhdGEgb2YgdGhlIHNlYXJjaGVkIG5vZGVcbiAgICAgKiBAcGFyYW0gY29tcGFyZXIgQSBjdXN0b20gY29tcGFyZXIgZnVuY3Rpb24gdGhhdCBldmFsdWF0ZXMgdGhlIHBhc3NlZCBgc2VhcmNoVGVybWAgYWdhaW5zdCBhbGwgbm9kZXMuXG4gICAgICogQHJldHVybnMgQXJyYXkgb2Ygbm9kZXMgdGhhdCBtYXRjaCB0aGUgc2VhcmNoLiBgbnVsbGAgaWYgbm8gbm9kZXMgYXJlIGZvdW5kLlxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdHJlZT5cbiAgICAgKiAgICAgPGlneC10cmVlLW5vZGUgKm5nRm9yPVwibGV0IG5vZGUgb2YgZGF0YVwiIFtkYXRhXT1cIm5vZGVcIj5cbiAgICAgKiAgICAgICAgICB7eyBub2RlLmxhYmVsIH19XG4gICAgICogICAgIDwvaWd4LXRyZWUtbm9kZT5cbiAgICAgKiA8L2lneC10cmVlPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBkYXRhOiBEYXRhRW50cnlbXSA9IEZFVENIRURfREFUQTtcbiAgICAgKiAuLi5cbiAgICAgKiBjb25zdCBtYXRjaGVkTm9kZXM6IElneFRyZWVOb2RlPERhdGFFbnRyeT5bXSA9IHRoaXMudHJlZS5maW5kTm9kZXM8RGF0YUVudHJ5PihzZWFyY2hUZXJtOiBkYXRhWzVdKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFVzaW5nIGEgY3VzdG9tIGNvbXBhcmVyXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBkYXRhOiBEYXRhRW50cnlbXSA9IEZFVENIRURfREFUQTtcbiAgICAgKiAuLi5cbiAgICAgKiBjb25zdCBjb21wYXJlcjogSWd4VHJlZVNlYXJjaFJlc29sdmVyID0gKGRhdGE6IGFueSwgbm9kZTogSWd4VHJlZU5vZGU8RGF0YUVudHJ5Pikge1xuICAgICAqICAgICAgcmV0dXJuIG5vZGUuZGF0YS5pbmRleCAlIDIgPT09IDA7XG4gICAgICogfVxuICAgICAqIGNvbnN0IGV2ZW5JbmRleE5vZGVzOiBJZ3hUcmVlTm9kZTxEYXRhRW50cnk+W10gPSB0aGlzLnRyZWUuZmluZE5vZGVzPERhdGFFbnRyeT4obnVsbCwgY29tcGFyZXIpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBmaW5kTm9kZXMoc2VhcmNoVGVybTogYW55LCBjb21wYXJlcj86IElneFRyZWVTZWFyY2hSZXNvbHZlcik6IElneFRyZWVOb2RlQ29tcG9uZW50PGFueT5bXSB8IG51bGwge1xuICAgICAgICBjb25zdCBjb21wYXJlRnVuYyA9IGNvbXBhcmVyIHx8IHRoaXMuX2NvbXBhcmVyO1xuICAgICAgICBjb25zdCByZXN1bHRzID0gdGhpcy5ub2Rlcy5maWx0ZXIobm9kZSA9PiBjb21wYXJlRnVuYyhzZWFyY2hUZXJtLCBub2RlKSk7XG4gICAgICAgIHJldHVybiByZXN1bHRzPy5sZW5ndGggPT09IDAgPyBudWxsIDogcmVzdWx0cztcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgaGFuZGxlS2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICB0aGlzLm5hdlNlcnZpY2UuaGFuZGxlS2V5ZG93bihldmVudCk7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIG92ZXJyaWRlIG5nT25Jbml0KCkge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgICAgICB0aGlzLmRpc2FibGVkQ2hhbmdlLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKS5zdWJzY3JpYmUoKGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMubmF2U2VydmljZS51cGRhdGVfZGlzYWJsZWRfY2FjaGUoZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFjdGl2ZU5vZGVCaW5kaW5nQ2hhbmdlLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKS5zdWJzY3JpYmUoKG5vZGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kVG9Ob2RlKHRoaXMubmF2U2VydmljZS5hY3RpdmVOb2RlKTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsTm9kZUludG9WaWV3KG5vZGU/LmhlYWRlcj8ubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRlbnNpdHlDaGFuZ2VkLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbE5vZGVJbnRvVmlldyh0aGlzLm5hdlNlcnZpY2UuYWN0aXZlTm9kZT8uaGVhZGVyLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN1YlRvQ29sbGFwc2luZygpO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHRoaXMubm9kZXMuY2hhbmdlcy5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3ViVG9DaGFuZ2VzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNjcm9sbE5vZGVJbnRvVmlldyh0aGlzLm5hdlNlcnZpY2UuYWN0aXZlTm9kZT8uaGVhZGVyPy5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgdGhpcy5zdWJUb0NoYW5nZXMoKTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMudW5zdWJDaGlsZHJlbiQubmV4dCgpO1xuICAgICAgICB0aGlzLnVuc3ViQ2hpbGRyZW4kLmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSQubmV4dCgpO1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBleHBhbmRUb05vZGUobm9kZTogSWd4VHJlZU5vZGU8YW55Pikge1xuICAgICAgICBpZiAobm9kZSAmJiBub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUucGF0aC5mb3JFYWNoKG4gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChuICE9PSBub2RlICYmICFuLmV4cGFuZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG4uZXhwYW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdWJUb0NvbGxhcHNpbmcoKSB7XG4gICAgICAgIHRoaXMubm9kZUNvbGxhcHNpbmcucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpLnN1YnNjcmliZShldmVudCA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuY2FuY2VsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5uYXZTZXJ2aWNlLnVwZGF0ZV92aXNpYmxlX2NhY2hlKGV2ZW50Lm5vZGUsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubm9kZUV4cGFuZGluZy5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSkuc3Vic2NyaWJlKGV2ZW50ID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5jYW5jZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5hdlNlcnZpY2UudXBkYXRlX3Zpc2libGVfY2FjaGUoZXZlbnQubm9kZSwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3ViVG9DaGFuZ2VzKCkge1xuICAgICAgICB0aGlzLnVuc3ViQ2hpbGRyZW4kLm5leHQoKTtcbiAgICAgICAgY29uc3QgdG9CZVNlbGVjdGVkID0gWy4uLnRoaXMuZm9yY2VTZWxlY3RdO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLnNlbGVjdE5vZGVzV2l0aE5vRXZlbnQodG9CZVNlbGVjdGVkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZm9yY2VTZWxlY3QgPSBbXTtcbiAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgbm9kZS5leHBhbmRlZENoYW5nZS5waXBlKHRha2VVbnRpbCh0aGlzLnVuc3ViQ2hpbGRyZW4kKSkuc3Vic2NyaWJlKG5vZGVTdGF0ZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5uYXZTZXJ2aWNlLnVwZGF0ZV92aXNpYmxlX2NhY2hlKG5vZGUsIG5vZGVTdGF0ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5vZGUuY2xvc2VBbmltYXRpb25Eb25lLnBpcGUodGFrZVVudGlsKHRoaXMudW5zdWJDaGlsZHJlbiQpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldEVsZW1lbnQgPSB0aGlzLm5hdlNlcnZpY2UuZm9jdXNlZE5vZGU/LmhlYWRlci5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsTm9kZUludG9WaWV3KHRhcmdldEVsZW1lbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBub2RlLm9wZW5BbmltYXRpb25Eb25lLnBpcGUodGFrZVVudGlsKHRoaXMudW5zdWJDaGlsZHJlbiQpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldEVsZW1lbnQgPSB0aGlzLm5hdlNlcnZpY2UuZm9jdXNlZE5vZGU/LmhlYWRlci5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsTm9kZUludG9WaWV3KHRhcmdldEVsZW1lbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5hdlNlcnZpY2UuaW5pdF9pbnZpc2libGVfY2FjaGUoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNjcm9sbE5vZGVJbnRvVmlldyhlbDogSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgaWYgKCFlbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGVSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IHRyZWVSZWN0ID0gdGhpcy5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCB0b3BPZmZzZXQgPSB0cmVlUmVjdC50b3AgPiBub2RlUmVjdC50b3AgPyBub2RlUmVjdC50b3AgLSB0cmVlUmVjdC50b3AgOiAwO1xuICAgICAgICBjb25zdCBib3R0b21PZmZzZXQgPSB0cmVlUmVjdC5ib3R0b20gPCBub2RlUmVjdC5ib3R0b20gPyBub2RlUmVjdC5ib3R0b20gLSB0cmVlUmVjdC5ib3R0b20gOiAwO1xuICAgICAgICBjb25zdCBzaG91bGRTY3JvbGwgPSAhIXRvcE9mZnNldCB8fCAhIWJvdHRvbU9mZnNldDtcbiAgICAgICAgaWYgKHNob3VsZFNjcm9sbCAmJiB0aGlzLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsSGVpZ2h0ID4gdGhpcy5uYXRpdmVFbGVtZW50LmNsaWVudEhlaWdodCkge1xuICAgICAgICAgICAgLy8gdGhpcy5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcCA9IG5vZGVSZWN0LnkgLSB0cmVlUmVjdC55IC0gbm9kZVJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcCA9XG4gICAgICAgICAgICB0aGlzLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsVG9wICsgYm90dG9tT2Zmc2V0ICsgdG9wT2Zmc2V0ICsgKHRvcE9mZnNldCA/IC0xIDogKzEpICogbm9kZVJlY3QuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfY29tcGFyZXIgPSA8VD4oZGF0YTogVCwgbm9kZTogSWd4VHJlZU5vZGVDb21wb25lbnQ8VD4pID0+IG5vZGUuZGF0YSA9PT0gZGF0YTtcblxufVxuIiwiPGRpdiBjbGFzcz1cImlneC10cmVlX19yb290XCIgcm9sZT1cInRyZWVcIiAoa2V5ZG93bik9XCJoYW5kbGVLZXlkb3duKCRldmVudClcIj5cbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJpZ3gtdHJlZS1ub2RlXCI+PC9uZy1jb250ZW50PlxuPC9kaXY+XG4iXX0=